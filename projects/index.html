<!DOCTYPE html>
<html lang="en-US" itemscope itemtype="http://schema.org/WebPage">

<head>
	
	<meta charset="utf-8">
<title>Projects</title>


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">

<meta name="theme-name" content="bigspring-hugo" />















<link rel="shortcut icon" href="/images/logos/logo_small_wb_hu68a4318163ff8e011babdec4caf974c7_3412_96x0_resize_lanczos_3.png" type="image/x-icon">
<link rel="icon" href="/images/logos/logo_small_wb_hu68a4318163ff8e011babdec4caf974c7_3412_96x0_resize_lanczos_3.png" type="image/x-icon">
<link rel="icon" type="image/png" sizes="48x48" href="/images/logos/logo_small_wb_hu68a4318163ff8e011babdec4caf974c7_3412_48x0_resize_lanczos_3.png">
<link rel="icon" type="image/png" sizes="96x96" href="/images/logos/logo_small_wb_hu68a4318163ff8e011babdec4caf974c7_3412_96x0_resize_lanczos_3.png">
<link rel="apple-touch-icon" sizes="144x144" href="/images/logos/logo_small_wb_hu68a4318163ff8e011babdec4caf974c7_3412_144x0_resize_lanczos_3.png">







<link rel="manifest" href="/manifest.webmanifest" />
<meta
  name="msapplication-TileColor"
  content="#006388" />
<meta
  name="theme-color"
  content="#fff" />




















  <base href="https://odissei-soda.nl/projects/" />







  


<title>Projects</title>















  <meta
    name="keywords"
    content="ODISSEI, Social data science, SoDa team" />




<meta
  name="description"
  content="This is meta description" />



  <meta name="author" content="SoDa team" />






  
  












  

  
  
  


  
  


  





<meta property="og:title" content="Projects" />
<meta property="og:description" content="This is meta description" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://odissei-soda.nl/projects/" />


<meta name="twitter:title" content="Projects" />
<meta name="twitter:description" content="This is meta description" />



  <meta name="twitter:creator" content="@SoDa team" />















  













  



	
	
	
<meta http-equiv="x-dns-prefetch-control" content="on" />
<link rel="preconnect" href="//ajax.googleapis.com" />
<link
  rel="preconnect"
  href="https://fonts.gstatic.com"
  crossorigin="anonymous" />
<link rel="preconnect" href="https://use.fontawesome.com" crossorigin />
<link rel="preconnect" href="//cdnjs.cloudflare.com" />
<link rel="preconnect" href="//www.googletagmanager.com" />
<link rel="preconnect" href="//www.google-analytics.com" />
<link rel="dns-prefetch" href="https://fonts.gstatic.com" />
<link rel="dns-prefetch" href="https://use.fontawesome.com" />
<link rel="dns-prefetch" href="//ajax.googleapis.com" />
<link rel="dns-prefetch" href="//cdnjs.cloudflare.com" />
<link rel="dns-prefetch" href="//www.googletagmanager.com" />
<link rel="dns-prefetch" href="//www.google-analytics.com" />
<link rel="dns-prefetch" href="//fonts.googleapis.com" />
<link rel="dns-prefetch" href="//connect.facebook.net" />
<link rel="dns-prefetch" href="//platform.linkedin.com" />
<link rel="dns-prefetch" href="//platform.twitter.com" />




  
    
  

  
    
  

  
    
  

  
    
  

  
    
  









<link rel="stylesheet" href="/css/style.css" /> 


	
</head>

<body>
	
	
	


  <div class="preloader">
    
    
    
    
  </div>

  <script>
    (function () {
      "use strict";
      window.addEventListener("load", function () {
        document.querySelector(".preloader").style.display = "none";
      });
    })();
  </script>


	

	
	
	
	
<header class="navigation">
  <div class="container">
    
    <nav class="navbar navbar-expand-lg navbar-light">
      
      <a class="navbar-brand" href="/">
        















  









  
  
  


  
  


  
  
    
    
  
  

  
  
    
    
      
      


      
      
        
        
      
      
    
  
  

  
    <img
      fetchpriority="high"
      decoding="async"
      class="img img-light"
      width="250"
      height=""
      src="/images/logos/soda_logo.svg"
      alt="ODISSEI SoDa team"
      onerror="this.onerror=null;this.src='';" />

    <img
      fetchpriority="high"
      decoding="async"
      class="img img-dark"
      width="250"
      height=""
      src="/images/logos/soda_logo_white.svg"
      alt="ODISSEI SoDa team"
      onerror="this.onerror=null;this.src='';" />
  
  


      </a>

      <div class="d-flex align-items-center">
        
        
        
        <button aria-label="navbar toggler" class="navbar-toggler border-0 h4 mb-0" type="button" data-bs-toggle="collapse" aria-expanded="false" data-bs-target="#navigation">
          <i class="fas fa-bars"></i>
          <i class="fa-solid fa-xmark"></i>
        </button>

        
      </div>

      <div class="collapse navbar-collapse text-center" id="navigation">
        <ul class="navbar-nav mx-auto">
          
          
          
          
          
          
          
          <li class="nav-item ">
            <a class="nav-link" 
              href="/">Home</a>
          </li>
          
          
          
          
          
          
          <li class="nav-item ">
            <a class="nav-link" 
              href="/principles/">About</a>
          </li>
          
          
          
          
          
          
          <li class="nav-item active">
            <a class="nav-link" 
              href="/projects/">Projects</a>
          </li>
          
          
          
          
          
          
          <li class="nav-item ">
            <a class="nav-link" 
              href="/workshops/">Workshops</a>
          </li>
          
          
          
          
          
          
          <li class="nav-item ">
            <a class="nav-link" 
              href="/team/">Team</a>
          </li>
          
          
          
          
          
          
          <li class="nav-item ">
            <a class="nav-link" 
              href="/fellowship/">Fellowship</a>
          </li>
          
          
          
          
          
          
          <li class="nav-item ">
            <a class="nav-link" 
              href="/tutorials/">Tutorials</a>
          </li>
          
          
        </ul>

        
        

        
        
        <a href="https://docs.google.com/forms/d/e/1FAIpQLSfTVvJgMs6teGUltv9ZAI3GC_w8PQvLDGx6tqUqfFcTEyTm-A/viewform"
          class="btn btn-sm btn-primary ms-lg-4 mt-2 mt-lg-0">Contact us</a>
        

        
      </div>
    </nav>
  </div>
</header>






	<main>
		


<div>
<section class="section pb-0">
  <div class="container text-center">
    <div class="container">
      <div class="row">
        <div class="col-lg-6 mx-auto">
          <h1 class="h2 mb-3">Projects</h1>
          
          <p class="mb-0 fw-500">Here you can find descriptions and links to projects we worked on in the past.</p>
          
        </div>
      </div>
    </div>
  </div>
</section>
</div>






<section class="section pb-3 pt-5">
  <div class="container">
    <div class="row gy-5 justify-content-center">
      <div class="col-xl-7 col-lg-7 col-sm-6 text-center">
        <ul>
          
          <li class="list-inline-item me-5 h5"><a href="#Collaborations" class="text-primary">Collaborations</a></li>
          
          <li class="list-inline-item me-5 h5"><a href="#Consultations" class="text-primary">Consultations</a></li>
          
        </ul>
      </div>
    </div>
  </div>
</section>












<section class="section">
  <div class="container">
    <div>
      <h3 class="section-title h4" id="Collaborations">Collaborations</h3>
    </div>
    <div class="row gy-5 justify-content-center">
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Time-use imputation for modelling emissions</h3>
            <div class="mt-3">
              <div class="content mb-4">How does gendered behaviour influence the carbon emissions of families in the Netherlands? In this project, we combine time-use surveys with expenditure surveys on the large-scale microdata of Statistics Netherlands to answer this question.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Maike Weiper, Erik-Jan van Kesteren, Qixiang Fang</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Using NLP techniques to analyze biodiversity narratives in financial reports</h3>
            <div class="mt-3">
              <div class="content mb-4">To extract information about biodiversity in a wide range of companies&#39; financial reports, we are helping to develop a LLM-based annotation pipeline which parse unstructured pdf reports.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Catalina Papari, Qixiang Fang</div>
            </div>
          </div>
          
          <a href="https://github.com/sodascience/BiodiversityASSET">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Project page/code <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Creating a historical disease database</h3>
            <div class="mt-3">
              <div class="content mb-4">How common was cholera in May 1866 in Rotterdam? What about the disease environment in Groningen in the early 1830&#39;s? In this project we are creating a historical database of common diseases such as cholera using Delpher newspaper data.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Kristina Thompson, Erik-Jan van Kesteren, Qixiang Fang</div>
            </div>
          </div>
          
          <a href="https://odissei-soda.nl/fellowship/">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Learn more about our fellowships <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Harmonizing longitudinal datasets to estimate psychological impact of COVID</h3>
            <div class="mt-3">
              <div class="content mb-4">Harmonize recovery in mental health after the COVID-19 pandemic in different datasets. We built pipelines to harmonize different datasets, and consulted on how to analyze and visualize the data.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Keenan Ramsey, Erik-Jan van Kesteren, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">The causal impact of prenatal poverty</h3>
            <div class="mt-3">
              <div class="content mb-4">What are the impacts of poverty in the prenatal period on children&#39;s health outcomes? Which mechanisms might be suitable policy intervention targets for these potential negative effects?</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Nadya Ali, Erik-Jan van Kesteren, Javier Garcia-Bernardo, Marion van den Heuvel</div>
            </div>
          </div>
          
          <a href="https://odissei-soda.nl/fellowship/">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Learn more about our fellowships <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Policy intervention assessment in primary schools</h3>
            <div class="mt-3">
              <div class="content mb-4">We are helping to compute individual causal effects of a policy intervention in primary schools in Rotterdam. For this, we are exploring the use of advanced quasi-experimental methods such as synthetic controls.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Gijs Custers, Erik-Jan van Kesteren, Oisín Ryan</div>
            </div>
          </div>
          
          <a href="https://odissei-data.nl/en/2023/03/soda-team-workshop-causal-impact-assessment/">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Learn more about causal impact assessment <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Machine learning pipeline for early life opportunity</h3>
            <div class="mt-3">
              <div class="content mb-4">We are helping with the creation of a data analysis and machine learning pipeline for the project &#34;Kansrijke start&#34;, which aims to investigate which markers in the first 1000 days since conception are predictive of adverse events later in life.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Wessel Kraaij, Erik-Jan van Kesteren, Anton Schreuder, Richard van Dijk</div>
            </div>
          </div>
          
          <a href="https://odissei-data.nl/en/using-odissei/microdata-access/">
          <div class="card-footer p-5 pt-0 pb-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Read more about Microdata Access <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          <a href="https://www.staff.universiteitleiden.nl/news/2021/06/a-good-start-for-every-child-and-how-data-science-can-help">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Project page/code <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Computational models for word and non-word associations</h3>
            <div class="mt-3">
              <div class="content mb-4">We are collaborating on a project for computationally modelling people&#39;s intuitions about various associations of both real words and non-words (e.g., novel words or company names) for the Dutch language. The project will result in an easy-to-use openly available application in which (non-)words can be analyzed for various associations that they may evoke as well as give a list of semantically similar words.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Giovanni Cassani, Erik-Jan van Kesteren, Aron Joosse</div>
            </div>
          </div>
          
          <a href="https://odissei-soda.nl/fellowship/">
          <div class="card-footer p-5 pt-0 pb-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Learn more about our fellowships <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          <a href="https://github.com/sodascience/dutch_sound_symbolism">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Project page/code <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Predicting fertility with interpretable machine learning</h3>
            <div class="mt-3">
              <div class="content mb-4">We collaborate on finding the limits of predictability for fertility intentions using a mass collaboration (benchmark). We are opening up the participant&#39;s models to understand what information is captured by highly predictive models, and to disaggregate the predictions of the models to assess geographical and demographic biases.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Gert Stulp, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
          <a href="https://stulp.gmw.rug.nl/prefer/">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Project page/code <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Trust in public institutions</h3>
            <div class="mt-3">
              <div class="content mb-4">We are creating a pipeline and dashboard to evaluate how trust on European public institutions evolves during pandemic.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Patrick Brown, Javier Garcia-Bernardo, Matthijs Vollenbroek, Stijn Peeters, Marc Tuters</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">COVID-19 spread in social networks</h3>
            <div class="mt-3">
              <div class="content mb-4">Together with RIVM and the ministry of health, the SoDa team is co-authoring a scientific paper on the spread of COVID-19 in schools in the Netherlands.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: RIVM, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Linking datasets based on company names</h3>
            <div class="mt-3">
              <div class="content mb-4">Linking databases on company names is a challenging task. Company names are usually not unique and can have many spelling variations. We helped conduct a sensitivity analysis for different methods of linking these databases, which can be used to answer many different social science research questions about companies in the Netherlands.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Peter Gerbrands, Jonathan de Bruin, Wim Coreynen</div>
            </div>
          </div>
          
          <a href="https://firmbackbone.nl/">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Project page/code <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Synthetic register data for open science</h3>
            <div class="mt-3">
              <div class="content mb-4">We created a workflow using existing software packages to generate synthetic datasets for the Statistics Netherlands microdata architecture. These synthetic datasets can then be used as example datasets when sharing analyses (but not original data!) with researchers.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Jan Kabatek, Erik-Jan van Kesteren, Kyuri Park</div>
            </div>
          </div>
          
          <a href="https://odissei-data.nl/en/using-odissei/microdata-access/">
          <div class="card-footer p-5 pt-0 pb-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Read more about Microdata Access <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          <a href="https://github.com/sodascience/synthpop.extract">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Project page/code <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Benchmarking for social science</h3>
            <div class="mt-3">
              <div class="content mb-4">We helped to design and set up a benchmark for a social data science challenge at the end of the SICSS-ODISSEI summerschool. The benchmark was based on microdata from Statistics Netherlands.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Paulina Pankowska, Javier Garcia-Bernardo, Adrienne Mendrik</div>
            </div>
          </div>
          
          <a href="https://odissei-data.nl/en/benchmarking/">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Read more about ODISSEI Benchmarking <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Metadata for synthetization</h3>
            <div class="mt-3">
              <div class="content mb-4">We are developing a metadata format which includes variable-level statistical information. This format can then be used to generate fake, synthetic datasets for testing purposes using a python package.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Ricarda Braukmann, Erik-Jan van Kesteren, Raoul Schram</div>
            </div>
          </div>
          
          <a href="https://github.com/sodascience/metasyn">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Project page/code <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Deviance in art automatic data collection</h3>
            <div class="mt-3">
              <div class="content mb-4">We created an automated data collection program (a &#34;scraper&#34;) to make a database of artworks with varying levels of deviance. This database will be used in research on how to measure deviance in art.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Eftychia Stamkou, Javier Garcia-Bernardo, Raoul Schram</div>
            </div>
          </div>
          
          <a href="https://github.com/sodascience/artscraper">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Project page/code <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">COVID-19 spread in social networks</h3>
            <div class="mt-3">
              <div class="content mb-4">Together with RIVM and the ministry of health, the SoDa team explored how to analyze the spread of COVID-19 in social networks, making use of the CBS social network files. The outcome of the project is a report for the ministry of health.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: RIVM, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Anonymity preserving collection of whatsapp data</h3>
            <div class="mt-3">
              <div class="content mb-4">We are creating a script to extract information from Whatsapp data packages, allowing to link data from different people while preserving the privacy of those people. This project is part of the ODISSEI LISS grant “Assessing Mobile Instant Messenger Networks with Donated Data”</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Laura Boeschoten, Javier Garcia-Bernardo, Parisa Zahedi, Shiva Nadi, Rense Corten</div>
            </div>
          </div>
          
          <a href="https://github.com/sodascience/port-poc">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Project page/code <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Supercomputing for social scientists</h3>
            <div class="mt-3">
              <div class="content mb-4">We co-created and co-taught a full-day workshop on high-performance computing for social scientists.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Carlos Teijeiro Barjas, Erik-Jan van Kesteren, Benjamin Czaja</div>
            </div>
          </div>
          
          <a href="https://github.com/sodascience/ossc_workshop">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Project page/code <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Population network data processing</h3>
            <div class="mt-3">
              <div class="content mb-4">We have helped with the implementation of the Statistics Netherlands population network data files in order to make them available to network researchers. These network data files can be used to develop network analysis models.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Tom Emery, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
          <a href="https://doi.org/10.1093/esr/jcac026">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Project page/code <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Empathy diagnostics dashboard</h3>
            <div class="mt-3">
              <div class="content mb-4">We created a pilot for an interactive questionnaire app which immediately generates a diagnostic report based on the inputs. This app is now used to study empathy in anti-social adolescents.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Minet de Wied, Javier Garcia-Bernardo, Shiva Nadi, Parisa Zahedi</div>
            </div>
          </div>
          
          <a href="https://odissei-data.nl/en/2022/03/first-aid-for-data-questions-how-soda-can-support-researchers-with-the-development-of-innovative-applications/">
          <div class="card-footer p-5 pt-0 pb-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Read more at ODISSEI <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          <a href="https://github.com/sodascience/empathy-viz">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Project page/code <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Inference from volunteer data</h3>
            <div class="mt-3">
              <div class="content mb-4">We created an analysis pipeline as part of a paper which outlines how to perform precise statistical inference (correcting for geospatial selection bias) using volunteer-generated data.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Peter Lugtig, Erik-Jan van Kesteren, Annemarie Timmers, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
          <a href="https://github.com/sodascience/night_globe">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Project page/code <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Housing market data engineering</h3>
            <div class="mt-3">
              <div class="content mb-4">We performed data engineering work to transform 10TB of online marketing (clicks) data from a large online housing platform into an analyzable format. These datasets are used in research surrounding search behaviour on the housing market in the Netherlands. We made the processed data available as an open dataset.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Joep Steegmans, Jonathan de Bruin</div>
            </div>
          </div>
          
          <a href="https://doi.org/10.1016/j.dib.2021.107327">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Project page/code <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Citizen science website</h3>
            <div class="mt-3">
              <div class="content mb-4">To get an overview of what citizen science projects are available in the Netherlands, we have created a website with an overview of such projects. The community can contribute their own projects via the gitub page!</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Peter Lugtig, Jonathan de Bruin, Leonardo Vida, Annemarie Timmers</div>
            </div>
          </div>
          
          <a href="https://github.com/sodascience/awesome-citizen-science-nl">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Project page/code <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Geoenrichment</h3>
            <div class="mt-3">
              <div class="content mb-4">We have created an R-package to perform geo-enrichment of datasets using openstreetmaps. Enriching geo-coded (latitude/longitude) data sets with features from the physical surroundings enables researchers to take into account spatial surroundings in statistical models.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Peter Lugtig, Erik-Jan van Kesteren, Leonardo Vida</div>
            </div>
          </div>
          
          <a href="https://github.com/sodascience/osmenrich">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Project page/code <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Geoenrichment docker images</h3>
            <div class="mt-3">
              <div class="content mb-4">Geo-enrichment requires transferring large amounts of data from a geospatial database to a computer program. Public APIs served over the internet are usually too slow for this purpose. Hence, we have created a docker image so that the API for our osmenrich R package can be run locally.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Peter Lugtig, Erik-Jan van Kesteren, Leonardo Vida</div>
            </div>
          </div>
          
          <a href="https://github.com/sodascience/osmenrich_docker">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Project page/code <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            <h3 class="h5">Kansenkaart analysis pipeline</h3>
            <div class="mt-3">
              <div class="content mb-4">Using large data sets from Statistics Netherlands, we developed a data pre-processing and analysis pipeline for estimating expectations concerning the inequality of opportunity in The Netherlands using the ODISSEI Secure Supercomputer (OSSC). These estimates will be available on the project website.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Bastian Ravesteijn, Erik-Jan van Kesteren, Helen Lam</div>
            </div>
          </div>
          
          <a href="https://odissei-data.nl/en/linking-to-the-ossc/">
          <div class="card-footer p-5 pt-0 pb-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Find out more about ODISSEI OSSC <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          <a href="https://kansenkaart.nl">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Project page/code <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    </div>
  </div>
</section>




<section class="section">
  <div class="container">
    <div>
      <h3 class="section-title h4" id="Consultations">Consultations</h3>
    </div>
    <div class="row gy-5 justify-content-center">
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Migrants&rsquo; inclusion in the financial system</h3>
            <div class="mt-3">
              <div class="content mb-4">We brainstormed about ways to investigate financial inclusion using register data, focussing on study loans</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Lisa van Dongen, Erik-Jan van Kesteren</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Text analysis of primary school booklets</h3>
            <div class="mt-3">
              <div class="content mb-4">We discussed ways in which primary schools in the Netherlands could be analysed in terms of their substantive principles, using regulated information booklets the schools are required to make available.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Sara Geven, Erik-Jan van Kesteren</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Relating latent classes to substantive predictors</h3>
            <div class="mt-3">
              <div class="content mb-4">We went over an implemented latent class analysis and discussed how external variables could be related to these latent classes, ideally via latent class regression-type analyses.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Christine Hedde-von Westernhagen, Erik-Jan van Kesteren</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Causality and social tipping points</h3>
            <div class="mt-3">
              <div class="content mb-4">We discussed how to match individuals. We discussed how to use CBS data to study social diffusion at the spatial and family level.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Christine Hedde-von Westernhagen, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">CBS longitudinal data</h3>
            <div class="mt-3">
              <div class="content mb-4">We discussed how to disentangle changes in network metrics due to changes in demography and actual changes in mechanisms</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Eszter Boyanki , Javier Garcia-Bernardo</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">LLM-driven annotation application and datasets for psychological research about life goals</h3>
            <div class="mt-3">
              <div class="content mb-4">We discussed a potential collaboration on developing an open-source, LLM-driven application for annotating open-ended survey responses about life goals and making the resulting dataset available.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Vinicius Coscioni, Qixiang Fang, Qixiang Fang</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Measuring diversity at tiny geographical scales using CBS data</h3>
            <div class="mt-3">
              <div class="content mb-4">We discussed potential ways to use CBS data to measure diversity at different scales---street, neighborhood, radius. We discussed ways in which SoDa could support the project.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Jona de Jong, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">How to deal with a slow and memory-intensive R package</h3>
            <div class="mt-3">
              <div class="content mb-4">We discussed the quality of a specific R package, and how to deal with problems of trying to analyze a huge dataset with it.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Joep Keuzenkamp, Erik-Jan van Kesteren</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Options for speeding up causal inference code on Snellius</h3>
            <div class="mt-3">
              <div class="content mb-4">We talked about how to run computationally intensive bootstrapping procedures on the Dutch national supercomputer Snellius.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Jack Fitzgerald, Erik-Jan van Kesteren</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">How to collect data from public government communications</h3>
            <div class="mt-3">
              <div class="content mb-4">We discussed how to collect text from the official government repository https://zoek.officielebekendmakingen.nl/  We discussed and made a quick example for a scraper using BeautifulSoup</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Gita Huijgen, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
          <a href="https://gist.github.com/jgarciab/8011e168ec2cc280be974c0f4ded1002">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Project page/code <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">How to make research about transparent AI communication more accessible through LLMs</h3>
            <div class="mt-3">
              <div class="content mb-4">We discussed different options for making  communication about AI more transparent for a wide audience by customizing a large language model, and allowing companies to ask the LLM for suggestions on their communications.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Sarah Marschlich, Erik-Jan van Kesteren, Alexandra Schwinges</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Debugging complex multilevel models in the CBS RA</h3>
            <div class="mt-3">
              <div class="content mb-4">We discussed what may be the causes of models failing during the fitting. We discussed a sereies of steps to test each of those causes.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Gemma Geuke, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Machine learning models predicting worse than simple models</h3>
            <div class="mt-3">
              <div class="content mb-4">We discussed issues of overfitting and discussed strategies on how to solve this issue.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Jiamin Ou, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Understanding diffusion in networks</h3>
            <div class="mt-3">
              <div class="content mb-4">We consulted about how to distinguish influence from selection in network contagion, and what type of analysis are possible</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Raphael Hoheisel, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Using NLP techniques to analyze biodiversity narratives in financial reports</h3>
            <div class="mt-3">
              <div class="content mb-4">We consulted on which NLP techniques could be appropriate for determining how companies talk about sustainability / biodiversity in their official reports.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Catalina Papari, Qixiang Fang</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Conceptualizing theories about boreout at work using online text data</h3>
            <div class="mt-3">
              <div class="content mb-4">We discussed how to validate a newly developed theory of the concept of bore-out in a systematic way against how this concept is portrayed in popular media and on websites. Additionally, we discussed to what extent automated text mining techniques could be useful in this content analysis process.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Madelon van Hooff, Javier Garcia-Bernardo, Erik-Jan van Kesteren</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Discussing future data donation studies</h3>
            <div class="mt-3">
              <div class="content mb-4">We explored different research ideas for using data donation in studies around music listening behaviour.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Hekmat Alrouh, Erik-Jan van Kesteren</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Finding closest geographical points quickly</h3>
            <div class="mt-3">
              <div class="content mb-4">We created a short script to find the closest neighbors within an x km radio to each person in a geographical dataset (each person has a latitude and longitude coordinates): https://github.com/sodascience/find_geo_peers_fast</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Ajay Bhaskarabhatla, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Analyzing the effect of engagement on online therapy</h3>
            <div class="mt-3">
              <div class="content mb-4">We developed an analysis plan for a randomized trial on the effect of online therapy with pre-post measurements and several relevant predictors.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Iris ten Klooster, Erik-Jan van Kesteren</div>
            </div>
          </div>
          
          <a href="https://github.com/sodascience/engage_model">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Project page/code <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Classifying economic segregation</h3>
            <div class="mt-3">
              <div class="content mb-4">We discussed how to use Non-Negative Matrix factorization to cluster neighborhoods into &#34;segregation profiles&#34;.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Ignacio Urria Yanez, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Assessing network contagion</h3>
            <div class="mt-3">
              <div class="content mb-4">We discussed how to assess network contagion (emotions being transmitted in networks) using longitudinal data</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Yuanyuan Hu, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Using CBS networks</h3>
            <div class="mt-3">
              <div class="content mb-4">What are options to use CBS networks</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Jona de Jong, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Combining corporate microdata</h3>
            <div class="mt-3">
              <div class="content mb-4">We discussed how to make sure that the researcher was retrieving all pertinent information from the Orbis IP database</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Catalina Papari, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Merging geographical data</h3>
            <div class="mt-3">
              <div class="content mb-4">Merging geographical data from different sources to predict the effect of coral bleaching on the economic impact of storms.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Joep Keuzenkamp, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Using ML to detect patterns in social data</h3>
            <div class="mt-3">
              <div class="content mb-4">How to use ML to model self-esteem change in education-to-work transitions</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Ketaki Diwan, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Extrapolating models between CBS datasets</h3>
            <div class="mt-3">
              <div class="content mb-4">We discussed how to combine survey data from two, non-overlaping surveys at CBS.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Maike Weiper, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Database of politician&rsquo;s faces</h3>
            <div class="mt-3">
              <div class="content mb-4">We discussed how to create a database of politician&#39;s faces to understand how they are framed in social media.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Wies Ruyters, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Extracting meaning from social media</h3>
            <div class="mt-3">
              <div class="content mb-4">We discussed which social media could be used to analyze geographical differences in emotions within Utrecht. We also discussed APIs and how to use them.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Mimi Ramirez Aranda, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Linking physical environment data to CBS microdata</h3>
            <div class="mt-3">
              <div class="content mb-4">We discussed how to combine spatial information with the ODIN travel survey at CBS to do spatial planning research on heat exposure.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Maarten Hogeweij, Erik-Jan van Kesteren</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Building a recommendation system for heat protection in homes</h3>
            <div class="mt-3">
              <div class="content mb-4">We discussed how to structure code to create a modular recommendation system based on a questionnaire about physical properties of study participants&#39; homes.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Maha Moustafa Habib Abdelraouf, Erik-Jan van Kesteren</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Linking LISS and CBS data to perform network analysis</h3>
            <div class="mt-3">
              <div class="content mb-4">We discussed ODISSEI grant opportunities to access LISS and CBS, and how to practically use network files at CBS.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Huyen Nguyen, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Estimating gender bias using NLP methods</h3>
            <div class="mt-3">
              <div class="content mb-4">We discussed how to use LLMs to detect gender bias in movies (using subtitle files), at the individual movie level.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Eftychia Stamkou, Erik-Jan van Kesteren &amp; Javier Garcia-Bernardo</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Implementing spatial data analysis for sociological research</h3>
            <div class="mt-3">
              <div class="content mb-4">We brainstormed about options and packages in R to incorporate spatial data in a sociological research project.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Kevin Wittenberg, Erik-Jan van Kesteren, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">How to structure code when my scripts become big?</h3>
            <div class="mt-3">
              <div class="content mb-4">We discussed how to structure code and datasets to make a large project more reproducible / reusable and easier to maintain.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Johannes Aengenheyster, Erik-Jan van Kesteren</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Initializing transport ABMs with a synthetic population</h3>
            <div class="mt-3">
              <div class="content mb-4">We thought about which open and closed data sources and which methods would be best to create a synthetic population for initializing an agent-based model of transport behaviour. We also discussed how to validate how good the synthetic population was.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Marco Pellegrino, Erik-Jan van Kesteren</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Network analysis of symptoms</h3>
            <div class="mt-3">
              <div class="content mb-4">Discussing different methods of preprocessing a medical dataset for subsequent network analysis to create symptom networks.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Willemijn van Waarden, Erik-Jan van Kesteren, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Software sustainability for Rsiena</h3>
            <div class="mt-3">
              <div class="content mb-4">We are helping to improve the sustainability of the RSiena network analysis software package, by helping to write a grant proposal and through a brainstorm session on efficient collaboration on GitHub.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Tom Snijders, Erik-Jan van Kesteren, Christian Steglich, Javier Garcia-Bernardo, Jonathan de Bruin</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Online Housing Market search strategy</h3>
            <div class="mt-3">
              <div class="content mb-4">Which search behaviour leads to finding a house quickly on the housing market? We brainstormed about how to perform analysis for a study on this topic using a large database of online housing search behaviour.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Joep Steegmans, Erik-Jan van Kesteren</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">FIRMBACKBONE</h3>
            <div class="mt-3">
              <div class="content mb-4">We regularly consult on FIRMBACKBONE, an initiative to collect an organically growing longitudinal data-infrastructure with information on Dutch companies for academic research. This data will become available for researchers affiliated with universities in The Netherlands through ODISSEI. We are consulting on the technical implementation of the FIRMBACKBONE project.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Peter Gerbrands, Javier Garcia-Bernardo, Erik-Jan van Kesteren, Jonathan de Bruin</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Computational efficiency</h3>
            <div class="mt-3">
              <div class="content mb-4">We brainstormed about how the analysis for a research project with big-data could be set up and whether it runs on a personal computer.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Thijs Lindner, Erik-Jan van Kesteren</div>
            </div>
          </div>
          
          <a href="https://odissei-data.nl/en/2021/12/first-aid-for-data-questions-consult-soda-about-computational-calculating-power/">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">Read more at ODISSEI <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">Synthetic data for agent-based models</h3>
            <div class="mt-3">
              <div class="content mb-4">Brainstorming with researchers about working with Statistics Netherlands data and generating synthetic data that can serve as input in an agent-based model.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Sanne Hettinga, Erik-Jan van Kesteren, Corentin Kuster</div>
            </div>
          </div>
          
        </div>
    </div>
    
    <div class="col-xl-4 col-lg-4 col-sm-6" data-aos="fade-in">
        <div class="soda-card h-100 shadow is-hoverable-border">
          <div class="card-body p-5 pb-0">
            
            <h3 class="h5">eScience consultations</h3>
            <div class="mt-3">
              <div class="content mb-4">We regularly join consultations done by the eScience center for projects that fall within the social sciences, for example in preparation for the ODISSEI-eScience grants.</div>
            </div>
            <div class="mt-3">
              <div class="content mb-4">Contributors: Various researchers, Jonathan de Bruin, Erik-Jan van Kesteren, Javier Garcia-Bernardo</div>
            </div>
          </div>
          
          <a href="https://odissei-data.nl/en/escience-grant/">
          <div class="card-footer p-5 pt-0 border-0 bg-transparent">
            <span class="text-primary fw-500">ODISSEI eScience Grants <i class="fas fa-arrow-right small ms-1"></i> </span>
          </div>
          </a>
          
        </div>
    </div>
    
    </div>
  </div>
</section>







	</main>

	
	
	<footer class="bg-light section pb-0">
  <div class="container">
    <div class="row justify-content-center">
      <div class="col-xl-11">
        <div class="section pt-0">
          <div class="row gy-4">
            <div class="col-lg-3 col-sm-6">
              
              <div class="h5 mb-4">About</div>
              <ul class="list-unstyled footer-list">
                
                <li><a href="/projects/" title="Projects">Projects</a></li>
                
                <li><a href="/principles/" title="Principles">Principles</a></li>
                
                <li><a href="/team/" title="Team">Team</a></li>
                
              </ul>
              
            </div>
            <div class="col-lg-3 col-sm-6">
              
              <div class="h5 mb-4">Support</div>
              <ul class="list-unstyled footer-list">
                
                <li><a href="/tutorials/" title="Tutorials">Tutorials</a></li>
                
                <li><a href="/workshops/" title="Workshops">Workshops</a></li>
                
                <li><a href="/fellowship/" title="Fellowship">Fellowship</a></li>
                
              </ul>
              
            </div>
            <div class="col-lg-3 col-sm-6">
              
            </div>
            <div class="col-lg-3 col-sm-6">
              <a class="d-block h5 mb-3" href="https://odissei-soda.nl/">
                















  









  
  
  


  
  


  
  
    
    
  
  

  
  
    
    
      
      


      
      
        
        
      
      
    
  
  

  
    <img
      fetchpriority="high"
      decoding="async"
      class="img img-light"
      width="250"
      height=""
      src="/images/logos/soda_logo.svg"
      alt="ODISSEI SoDa team"
      onerror="this.onerror=null;this.src='';" />

    <img
      fetchpriority="high"
      decoding="async"
      class="img img-dark"
      width="250"
      height=""
      src="/images/logos/soda_logo_white.svg"
      alt="ODISSEI SoDa team"
      onerror="this.onerror=null;this.src='';" />
  
  


              </a>
              <p class="mb-4">Follow us on social media.</p>
              
              <ul class="list-inline social-icons">
                
                <li class="list-inline-item"><a href="https://github.com/sodascience" title="GitHub"><i
                      class="fab fa-github"></i></a></li>
                
                <li class="list-inline-item"><a href="https://www.linkedin.com/company/odissei-soda" title="LinkedIn"><i
                      class="fab fa-linkedin"></i></a></li>
                
                <li class="list-inline-item"><a href="https://x.com/ODISSEI_SoDa" title="X/Twitter"><i
                      class="fab fa-x-twitter"></i></a></li>
                
                <li class="list-inline-item"><a href="https://bsky.app/profile/odissei-soda.bsky.social" title="Bluesky"><i
                      class="fab fa-square-bluesky"></i></a></li>
                
                <li class="list-inline-item"><a href="https://mastodon.social/@ODISSEI_SoDa" title="Mastodon"><i
                      class="fab fa-mastodon"></i></a></li>
                
              </ul>
              
            </div>
          </div>
        </div>
        
        <div class="border-top border-default text-center py-4">
          <small class="content"> Copyright by SoDa | Theme by <a target="_blank" rel="noopener noreferrer" href="https://gethugothemes.com/">GetHugoThemes</a>
          </small>
        </div>
        

      </div>
    </div>
  </div>
</footer>
	








<script crossorigin="anonymous" defer  integrity="sha512-dCIZHcmW8pL&#43;DPLWQFFEYQLuqKBywPohaIj0FJKVrrlZ6iljjXafVk&#43;5hh&#43;sRe8ffzZ6Hh9AK4OC6NcwxyEyNQ==" type="application/javascript">(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // ns-hugo:/tmp/hugo_cache/modules/filecache/modules/pkg/mod/github.com/gohugoio/hugo-mod-jslibs-dist/popperjs/v2@v2.21100.20000/package/dist/cjs/popper.js
  var require_popper = __commonJS({
    "ns-hugo:/tmp/hugo_cache/modules/filecache/modules/pkg/mod/github.com/gohugoio/hugo-mod-jslibs-dist/popperjs/v2@v2.21100.20000/package/dist/cjs/popper.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function getWindow(node) {
        if (node == null) {
          return window;
        }
        if (node.toString() !== "[object Window]") {
          var ownerDocument = node.ownerDocument;
          return ownerDocument ? ownerDocument.defaultView || window : window;
        }
        return node;
      }
      function isElement2(node) {
        var OwnElement = getWindow(node).Element;
        return node instanceof OwnElement || node instanceof Element;
      }
      function isHTMLElement(node) {
        var OwnElement = getWindow(node).HTMLElement;
        return node instanceof OwnElement || node instanceof HTMLElement;
      }
      function isShadowRoot(node) {
        if (typeof ShadowRoot === "undefined") {
          return false;
        }
        var OwnElement = getWindow(node).ShadowRoot;
        return node instanceof OwnElement || node instanceof ShadowRoot;
      }
      var max = Math.max;
      var min = Math.min;
      var round = Math.round;
      function getBoundingClientRect(element, includeScale) {
        if (includeScale === void 0) {
          includeScale = false;
        }
        var rect = element.getBoundingClientRect();
        var scaleX = 1;
        var scaleY = 1;
        if (isHTMLElement(element) && includeScale) {
          var offsetHeight = element.offsetHeight;
          var offsetWidth = element.offsetWidth;
          if (offsetWidth > 0) {
            scaleX = round(rect.width) / offsetWidth || 1;
          }
          if (offsetHeight > 0) {
            scaleY = round(rect.height) / offsetHeight || 1;
          }
        }
        return {
          width: rect.width / scaleX,
          height: rect.height / scaleY,
          top: rect.top / scaleY,
          right: rect.right / scaleX,
          bottom: rect.bottom / scaleY,
          left: rect.left / scaleX,
          x: rect.left / scaleX,
          y: rect.top / scaleY
        };
      }
      function getWindowScroll(node) {
        var win = getWindow(node);
        var scrollLeft = win.pageXOffset;
        var scrollTop = win.pageYOffset;
        return {
          scrollLeft,
          scrollTop
        };
      }
      function getHTMLElementScroll(element) {
        return {
          scrollLeft: element.scrollLeft,
          scrollTop: element.scrollTop
        };
      }
      function getNodeScroll(node) {
        if (node === getWindow(node) || !isHTMLElement(node)) {
          return getWindowScroll(node);
        } else {
          return getHTMLElementScroll(node);
        }
      }
      function getNodeName(element) {
        return element ? (element.nodeName || "").toLowerCase() : null;
      }
      function getDocumentElement(element) {
        return ((isElement2(element) ? element.ownerDocument : (
          // $FlowFixMe[prop-missing]
          element.document
        )) || window.document).documentElement;
      }
      function getWindowScrollBarX(element) {
        return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
      }
      function getComputedStyle2(element) {
        return getWindow(element).getComputedStyle(element);
      }
      function isScrollParent(element) {
        var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
        return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
      }
      function isElementScaled(element) {
        var rect = element.getBoundingClientRect();
        var scaleX = round(rect.width) / element.offsetWidth || 1;
        var scaleY = round(rect.height) / element.offsetHeight || 1;
        return scaleX !== 1 || scaleY !== 1;
      }
      function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
        if (isFixed === void 0) {
          isFixed = false;
        }
        var isOffsetParentAnElement = isHTMLElement(offsetParent);
        var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
        var documentElement = getDocumentElement(offsetParent);
        var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
        var scroll = {
          scrollLeft: 0,
          scrollTop: 0
        };
        var offsets = {
          x: 0,
          y: 0
        };
        if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
          if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
          isScrollParent(documentElement)) {
            scroll = getNodeScroll(offsetParent);
          }
          if (isHTMLElement(offsetParent)) {
            offsets = getBoundingClientRect(offsetParent, true);
            offsets.x += offsetParent.clientLeft;
            offsets.y += offsetParent.clientTop;
          } else if (documentElement) {
            offsets.x = getWindowScrollBarX(documentElement);
          }
        }
        return {
          x: rect.left + scroll.scrollLeft - offsets.x,
          y: rect.top + scroll.scrollTop - offsets.y,
          width: rect.width,
          height: rect.height
        };
      }
      function getLayoutRect(element) {
        var clientRect = getBoundingClientRect(element);
        var width = element.offsetWidth;
        var height = element.offsetHeight;
        if (Math.abs(clientRect.width - width) <= 1) {
          width = clientRect.width;
        }
        if (Math.abs(clientRect.height - height) <= 1) {
          height = clientRect.height;
        }
        return {
          x: element.offsetLeft,
          y: element.offsetTop,
          width,
          height
        };
      }
      function getParentNode(element) {
        if (getNodeName(element) === "html") {
          return element;
        }
        return (
          // this is a quicker (but less type safe) way to save quite some bytes from the bundle
          // $FlowFixMe[incompatible-return]
          // $FlowFixMe[prop-missing]
          element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
          element.parentNode || // DOM Element detected
          (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
          // $FlowFixMe[incompatible-call]: HTMLElement is a Node
          getDocumentElement(element)
        );
      }
      function getScrollParent(node) {
        if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
          return node.ownerDocument.body;
        }
        if (isHTMLElement(node) && isScrollParent(node)) {
          return node;
        }
        return getScrollParent(getParentNode(node));
      }
      function listScrollParents(element, list) {
        var _element$ownerDocumen;
        if (list === void 0) {
          list = [];
        }
        var scrollParent = getScrollParent(element);
        var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
        var win = getWindow(scrollParent);
        var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
        var updatedList = list.concat(target);
        return isBody ? updatedList : (
          // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
          updatedList.concat(listScrollParents(getParentNode(target)))
        );
      }
      function isTableElement(element) {
        return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
      }
      function getTrueOffsetParent(element) {
        if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
        getComputedStyle2(element).position === "fixed") {
          return null;
        }
        return element.offsetParent;
      }
      function getContainingBlock(element) {
        var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
        var isIE = navigator.userAgent.indexOf("Trident") !== -1;
        if (isIE && isHTMLElement(element)) {
          var elementCss = getComputedStyle2(element);
          if (elementCss.position === "fixed") {
            return null;
          }
        }
        var currentNode = getParentNode(element);
        while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
          var css = getComputedStyle2(currentNode);
          if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
            return currentNode;
          } else {
            currentNode = currentNode.parentNode;
          }
        }
        return null;
      }
      function getOffsetParent(element) {
        var window2 = getWindow(element);
        var offsetParent = getTrueOffsetParent(element);
        while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
          offsetParent = getTrueOffsetParent(offsetParent);
        }
        if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
          return window2;
        }
        return offsetParent || getContainingBlock(element) || window2;
      }
      var top = "top";
      var bottom = "bottom";
      var right = "right";
      var left = "left";
      var auto = "auto";
      var basePlacements = [top, bottom, right, left];
      var start = "start";
      var end = "end";
      var clippingParents = "clippingParents";
      var viewport = "viewport";
      var popper = "popper";
      var reference = "reference";
      var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
        return acc.concat([placement + "-" + start, placement + "-" + end]);
      }, []);
      var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
        return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
      }, []);
      var beforeRead = "beforeRead";
      var read = "read";
      var afterRead = "afterRead";
      var beforeMain = "beforeMain";
      var main = "main";
      var afterMain = "afterMain";
      var beforeWrite = "beforeWrite";
      var write = "write";
      var afterWrite = "afterWrite";
      var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
      function order(modifiers) {
        var map = /* @__PURE__ */ new Map();
        var visited = /* @__PURE__ */ new Set();
        var result = [];
        modifiers.forEach(function(modifier) {
          map.set(modifier.name, modifier);
        });
        function sort(modifier) {
          visited.add(modifier.name);
          var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
          requires.forEach(function(dep) {
            if (!visited.has(dep)) {
              var depModifier = map.get(dep);
              if (depModifier) {
                sort(depModifier);
              }
            }
          });
          result.push(modifier);
        }
        modifiers.forEach(function(modifier) {
          if (!visited.has(modifier.name)) {
            sort(modifier);
          }
        });
        return result;
      }
      function orderModifiers(modifiers) {
        var orderedModifiers = order(modifiers);
        return modifierPhases.reduce(function(acc, phase) {
          return acc.concat(orderedModifiers.filter(function(modifier) {
            return modifier.phase === phase;
          }));
        }, []);
      }
      function debounce(fn) {
        var pending;
        return function() {
          if (!pending) {
            pending = new Promise(function(resolve) {
              Promise.resolve().then(function() {
                pending = void 0;
                resolve(fn());
              });
            });
          }
          return pending;
        };
      }
      function format(str) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        return [].concat(args).reduce(function(p, c) {
          return p.replace(/%s/, c);
        }, str);
      }
      var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
      var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
      var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
      function validateModifiers(modifiers) {
        modifiers.forEach(function(modifier) {
          [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self) {
            return self.indexOf(value) === index;
          }).forEach(function(key) {
            switch (key) {
              case "name":
                if (typeof modifier.name !== "string") {
                  console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
                }
                break;
              case "enabled":
                if (typeof modifier.enabled !== "boolean") {
                  console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
                }
                break;
              case "phase":
                if (modifierPhases.indexOf(modifier.phase) < 0) {
                  console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
                }
                break;
              case "fn":
                if (typeof modifier.fn !== "function") {
                  console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
                }
                break;
              case "effect":
                if (modifier.effect != null && typeof modifier.effect !== "function") {
                  console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
                }
                break;
              case "requires":
                if (modifier.requires != null && !Array.isArray(modifier.requires)) {
                  console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
                }
                break;
              case "requiresIfExists":
                if (!Array.isArray(modifier.requiresIfExists)) {
                  console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
                }
                break;
              case "options":
              case "data":
                break;
              default:
                console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
                  return '"' + s + '"';
                }).join(", ") + '; but "' + key + '" was provided.');
            }
            modifier.requires && modifier.requires.forEach(function(requirement) {
              if (modifiers.find(function(mod) {
                return mod.name === requirement;
              }) == null) {
                console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
              }
            });
          });
        });
      }
      function uniqueBy(arr, fn) {
        var identifiers = /* @__PURE__ */ new Set();
        return arr.filter(function(item) {
          var identifier = fn(item);
          if (!identifiers.has(identifier)) {
            identifiers.add(identifier);
            return true;
          }
        });
      }
      function getBasePlacement(placement) {
        return placement.split("-")[0];
      }
      function mergeByName(modifiers) {
        var merged = modifiers.reduce(function(merged2, current) {
          var existing = merged2[current.name];
          merged2[current.name] = existing ? Object.assign({}, existing, current, {
            options: Object.assign({}, existing.options, current.options),
            data: Object.assign({}, existing.data, current.data)
          }) : current;
          return merged2;
        }, {});
        return Object.keys(merged).map(function(key) {
          return merged[key];
        });
      }
      function getViewportRect(element) {
        var win = getWindow(element);
        var html = getDocumentElement(element);
        var visualViewport = win.visualViewport;
        var width = html.clientWidth;
        var height = html.clientHeight;
        var x = 0;
        var y = 0;
        if (visualViewport) {
          width = visualViewport.width;
          height = visualViewport.height;
          if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
            x = visualViewport.offsetLeft;
            y = visualViewport.offsetTop;
          }
        }
        return {
          width,
          height,
          x: x + getWindowScrollBarX(element),
          y
        };
      }
      function getDocumentRect(element) {
        var _element$ownerDocumen;
        var html = getDocumentElement(element);
        var winScroll = getWindowScroll(element);
        var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
        var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
        var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
        var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
        var y = -winScroll.scrollTop;
        if (getComputedStyle2(body || html).direction === "rtl") {
          x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
        }
        return {
          width,
          height,
          x,
          y
        };
      }
      function contains(parent, child) {
        var rootNode = child.getRootNode && child.getRootNode();
        if (parent.contains(child)) {
          return true;
        } else if (rootNode && isShadowRoot(rootNode)) {
          var next = child;
          do {
            if (next && parent.isSameNode(next)) {
              return true;
            }
            next = next.parentNode || next.host;
          } while (next);
        }
        return false;
      }
      function rectToClientRect(rect) {
        return Object.assign({}, rect, {
          left: rect.x,
          top: rect.y,
          right: rect.x + rect.width,
          bottom: rect.y + rect.height
        });
      }
      function getInnerBoundingClientRect(element) {
        var rect = getBoundingClientRect(element);
        rect.top = rect.top + element.clientTop;
        rect.left = rect.left + element.clientLeft;
        rect.bottom = rect.top + element.clientHeight;
        rect.right = rect.left + element.clientWidth;
        rect.width = element.clientWidth;
        rect.height = element.clientHeight;
        rect.x = rect.left;
        rect.y = rect.top;
        return rect;
      }
      function getClientRectFromMixedType(element, clippingParent) {
        return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement2(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
      }
      function getClippingParents(element) {
        var clippingParents2 = listScrollParents(getParentNode(element));
        var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
        var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
        if (!isElement2(clipperElement)) {
          return [];
        }
        return clippingParents2.filter(function(clippingParent) {
          return isElement2(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body" && (canEscapeClipping ? getComputedStyle2(clippingParent).position !== "static" : true);
        });
      }
      function getClippingRect(element, boundary, rootBoundary) {
        var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
        var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
        var firstClippingParent = clippingParents2[0];
        var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
          var rect = getClientRectFromMixedType(element, clippingParent);
          accRect.top = max(rect.top, accRect.top);
          accRect.right = min(rect.right, accRect.right);
          accRect.bottom = min(rect.bottom, accRect.bottom);
          accRect.left = max(rect.left, accRect.left);
          return accRect;
        }, getClientRectFromMixedType(element, firstClippingParent));
        clippingRect.width = clippingRect.right - clippingRect.left;
        clippingRect.height = clippingRect.bottom - clippingRect.top;
        clippingRect.x = clippingRect.left;
        clippingRect.y = clippingRect.top;
        return clippingRect;
      }
      function getVariation(placement) {
        return placement.split("-")[1];
      }
      function getMainAxisFromPlacement(placement) {
        return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
      }
      function computeOffsets(_ref) {
        var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
        var basePlacement = placement ? getBasePlacement(placement) : null;
        var variation = placement ? getVariation(placement) : null;
        var commonX = reference2.x + reference2.width / 2 - element.width / 2;
        var commonY = reference2.y + reference2.height / 2 - element.height / 2;
        var offsets;
        switch (basePlacement) {
          case top:
            offsets = {
              x: commonX,
              y: reference2.y - element.height
            };
            break;
          case bottom:
            offsets = {
              x: commonX,
              y: reference2.y + reference2.height
            };
            break;
          case right:
            offsets = {
              x: reference2.x + reference2.width,
              y: commonY
            };
            break;
          case left:
            offsets = {
              x: reference2.x - element.width,
              y: commonY
            };
            break;
          default:
            offsets = {
              x: reference2.x,
              y: reference2.y
            };
        }
        var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
        if (mainAxis != null) {
          var len = mainAxis === "y" ? "height" : "width";
          switch (variation) {
            case start:
              offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
              break;
            case end:
              offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
              break;
          }
        }
        return offsets;
      }
      function getFreshSideObject() {
        return {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        };
      }
      function mergePaddingObject(paddingObject) {
        return Object.assign({}, getFreshSideObject(), paddingObject);
      }
      function expandToHashMap(value, keys) {
        return keys.reduce(function(hashMap, key) {
          hashMap[key] = value;
          return hashMap;
        }, {});
      }
      function detectOverflow(state, options) {
        if (options === void 0) {
          options = {};
        }
        var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
        var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
        var altContext = elementContext === popper ? reference : popper;
        var popperRect = state.rects.popper;
        var element = state.elements[altBoundary ? altContext : elementContext];
        var clippingClientRect = getClippingRect(isElement2(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
        var referenceClientRect = getBoundingClientRect(state.elements.reference);
        var popperOffsets2 = computeOffsets({
          reference: referenceClientRect,
          element: popperRect,
          strategy: "absolute",
          placement
        });
        var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
        var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
        var overflowOffsets = {
          top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
          bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
          left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
          right: elementClientRect.right - clippingClientRect.right + paddingObject.right
        };
        var offsetData = state.modifiersData.offset;
        if (elementContext === popper && offsetData) {
          var offset2 = offsetData[placement];
          Object.keys(overflowOffsets).forEach(function(key) {
            var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
            var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
            overflowOffsets[key] += offset2[axis] * multiply;
          });
        }
        return overflowOffsets;
      }
      var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
      var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
      var DEFAULT_OPTIONS = {
        placement: "bottom",
        modifiers: [],
        strategy: "absolute"
      };
      function areValidElements() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return !args.some(function(element) {
          return !(element && typeof element.getBoundingClientRect === "function");
        });
      }
      function popperGenerator(generatorOptions) {
        if (generatorOptions === void 0) {
          generatorOptions = {};
        }
        var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
        return function createPopper3(reference2, popper2, options) {
          if (options === void 0) {
            options = defaultOptions;
          }
          var state = {
            placement: "bottom",
            orderedModifiers: [],
            options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
            modifiersData: {},
            elements: {
              reference: reference2,
              popper: popper2
            },
            attributes: {},
            styles: {}
          };
          var effectCleanupFns = [];
          var isDestroyed = false;
          var instance = {
            state,
            setOptions: function setOptions(setOptionsAction) {
              var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
              cleanupModifierEffects();
              state.options = Object.assign({}, defaultOptions, state.options, options2);
              state.scrollParents = {
                reference: isElement2(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
                popper: listScrollParents(popper2)
              };
              var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
              state.orderedModifiers = orderedModifiers.filter(function(m) {
                return m.enabled;
              });
              if (true) {
                var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
                  var name = _ref.name;
                  return name;
                });
                validateModifiers(modifiers);
                if (getBasePlacement(state.options.placement) === auto) {
                  var flipModifier = state.orderedModifiers.find(function(_ref2) {
                    var name = _ref2.name;
                    return name === "flip";
                  });
                  if (!flipModifier) {
                    console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
                  }
                }
                var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
                if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
                  return parseFloat(margin);
                })) {
                  console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
                }
              }
              runModifierEffects();
              return instance.update();
            },
            // Sync update – it will always be executed, even if not necessary. This
            // is useful for low frequency updates where sync behavior simplifies the
            // logic.
            // For high frequency updates (e.g. `resize` and `scroll` events), always
            // prefer the async Popper#update method
            forceUpdate: function forceUpdate() {
              if (isDestroyed) {
                return;
              }
              var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
              if (!areValidElements(reference3, popper3)) {
                if (true) {
                  console.error(INVALID_ELEMENT_ERROR);
                }
                return;
              }
              state.rects = {
                reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
                popper: getLayoutRect(popper3)
              };
              state.reset = false;
              state.placement = state.options.placement;
              state.orderedModifiers.forEach(function(modifier) {
                return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
              });
              var __debug_loops__ = 0;
              for (var index = 0; index < state.orderedModifiers.length; index++) {
                if (true) {
                  __debug_loops__ += 1;
                  if (__debug_loops__ > 100) {
                    console.error(INFINITE_LOOP_ERROR);
                    break;
                  }
                }
                if (state.reset === true) {
                  state.reset = false;
                  index = -1;
                  continue;
                }
                var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
                if (typeof fn === "function") {
                  state = fn({
                    state,
                    options: _options,
                    name,
                    instance
                  }) || state;
                }
              }
            },
            // Async and optimistically optimized update – it will not be executed if
            // not necessary (debounced to run at most once-per-tick)
            update: debounce(function() {
              return new Promise(function(resolve) {
                instance.forceUpdate();
                resolve(state);
              });
            }),
            destroy: function destroy() {
              cleanupModifierEffects();
              isDestroyed = true;
            }
          };
          if (!areValidElements(reference2, popper2)) {
            if (true) {
              console.error(INVALID_ELEMENT_ERROR);
            }
            return instance;
          }
          instance.setOptions(options).then(function(state2) {
            if (!isDestroyed && options.onFirstUpdate) {
              options.onFirstUpdate(state2);
            }
          });
          function runModifierEffects() {
            state.orderedModifiers.forEach(function(_ref3) {
              var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
              if (typeof effect2 === "function") {
                var cleanupFn = effect2({
                  state,
                  name,
                  instance,
                  options: options2
                });
                var noopFn = function noopFn2() {
                };
                effectCleanupFns.push(cleanupFn || noopFn);
              }
            });
          }
          function cleanupModifierEffects() {
            effectCleanupFns.forEach(function(fn) {
              return fn();
            });
            effectCleanupFns = [];
          }
          return instance;
        };
      }
      var passive = {
        passive: true
      };
      function effect$2(_ref) {
        var state = _ref.state, instance = _ref.instance, options = _ref.options;
        var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
        var window2 = getWindow(state.elements.popper);
        var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
        if (scroll) {
          scrollParents.forEach(function(scrollParent) {
            scrollParent.addEventListener("scroll", instance.update, passive);
          });
        }
        if (resize) {
          window2.addEventListener("resize", instance.update, passive);
        }
        return function() {
          if (scroll) {
            scrollParents.forEach(function(scrollParent) {
              scrollParent.removeEventListener("scroll", instance.update, passive);
            });
          }
          if (resize) {
            window2.removeEventListener("resize", instance.update, passive);
          }
        };
      }
      var eventListeners = {
        name: "eventListeners",
        enabled: true,
        phase: "write",
        fn: function fn() {
        },
        effect: effect$2,
        data: {}
      };
      function popperOffsets(_ref) {
        var state = _ref.state, name = _ref.name;
        state.modifiersData[name] = computeOffsets({
          reference: state.rects.reference,
          element: state.rects.popper,
          strategy: "absolute",
          placement: state.placement
        });
      }
      var popperOffsets$1 = {
        name: "popperOffsets",
        enabled: true,
        phase: "read",
        fn: popperOffsets,
        data: {}
      };
      var unsetSides = {
        top: "auto",
        right: "auto",
        bottom: "auto",
        left: "auto"
      };
      function roundOffsetsByDPR(_ref) {
        var x = _ref.x, y = _ref.y;
        var win = window;
        var dpr = win.devicePixelRatio || 1;
        return {
          x: round(x * dpr) / dpr || 0,
          y: round(y * dpr) / dpr || 0
        };
      }
      function mapToStyles(_ref2) {
        var _Object$assign2;
        var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
        var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === "function" ? roundOffsets(offsets) : offsets, _ref3$x = _ref3.x, x = _ref3$x === void 0 ? 0 : _ref3$x, _ref3$y = _ref3.y, y = _ref3$y === void 0 ? 0 : _ref3$y;
        var hasX = offsets.hasOwnProperty("x");
        var hasY = offsets.hasOwnProperty("y");
        var sideX = left;
        var sideY = top;
        var win = window;
        if (adaptive) {
          var offsetParent = getOffsetParent(popper2);
          var heightProp = "clientHeight";
          var widthProp = "clientWidth";
          if (offsetParent === getWindow(popper2)) {
            offsetParent = getDocumentElement(popper2);
            if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
              heightProp = "scrollHeight";
              widthProp = "scrollWidth";
            }
          }
          offsetParent = offsetParent;
          if (placement === top || (placement === left || placement === right) && variation === end) {
            sideY = bottom;
            var offsetY = isFixed && win.visualViewport ? win.visualViewport.height : (
              // $FlowFixMe[prop-missing]
              offsetParent[heightProp]
            );
            y -= offsetY - popperRect.height;
            y *= gpuAcceleration ? 1 : -1;
          }
          if (placement === left || (placement === top || placement === bottom) && variation === end) {
            sideX = right;
            var offsetX = isFixed && win.visualViewport ? win.visualViewport.width : (
              // $FlowFixMe[prop-missing]
              offsetParent[widthProp]
            );
            x -= offsetX - popperRect.width;
            x *= gpuAcceleration ? 1 : -1;
          }
        }
        var commonStyles = Object.assign({
          position
        }, adaptive && unsetSides);
        if (gpuAcceleration) {
          var _Object$assign;
          return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
        }
        return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
      }
      function computeStyles(_ref4) {
        var state = _ref4.state, options = _ref4.options;
        var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
        if (true) {
          var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
          if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
            return transitionProperty.indexOf(property) >= 0;
          })) {
            console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
          }
        }
        var commonStyles = {
          placement: getBasePlacement(state.placement),
          variation: getVariation(state.placement),
          popper: state.elements.popper,
          popperRect: state.rects.popper,
          gpuAcceleration,
          isFixed: state.options.strategy === "fixed"
        };
        if (state.modifiersData.popperOffsets != null) {
          state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
            offsets: state.modifiersData.popperOffsets,
            position: state.options.strategy,
            adaptive,
            roundOffsets
          })));
        }
        if (state.modifiersData.arrow != null) {
          state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
            offsets: state.modifiersData.arrow,
            position: "absolute",
            adaptive: false,
            roundOffsets
          })));
        }
        state.attributes.popper = Object.assign({}, state.attributes.popper, {
          "data-popper-placement": state.placement
        });
      }
      var computeStyles$1 = {
        name: "computeStyles",
        enabled: true,
        phase: "beforeWrite",
        fn: computeStyles,
        data: {}
      };
      function applyStyles(_ref) {
        var state = _ref.state;
        Object.keys(state.elements).forEach(function(name) {
          var style = state.styles[name] || {};
          var attributes = state.attributes[name] || {};
          var element = state.elements[name];
          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }
          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function(name2) {
            var value = attributes[name2];
            if (value === false) {
              element.removeAttribute(name2);
            } else {
              element.setAttribute(name2, value === true ? "" : value);
            }
          });
        });
      }
      function effect$1(_ref2) {
        var state = _ref2.state;
        var initialStyles = {
          popper: {
            position: state.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
          },
          arrow: {
            position: "absolute"
          },
          reference: {}
        };
        Object.assign(state.elements.popper.style, initialStyles.popper);
        state.styles = initialStyles;
        if (state.elements.arrow) {
          Object.assign(state.elements.arrow.style, initialStyles.arrow);
        }
        return function() {
          Object.keys(state.elements).forEach(function(name) {
            var element = state.elements[name];
            var attributes = state.attributes[name] || {};
            var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
            var style = styleProperties.reduce(function(style2, property) {
              style2[property] = "";
              return style2;
            }, {});
            if (!isHTMLElement(element) || !getNodeName(element)) {
              return;
            }
            Object.assign(element.style, style);
            Object.keys(attributes).forEach(function(attribute) {
              element.removeAttribute(attribute);
            });
          });
        };
      }
      var applyStyles$1 = {
        name: "applyStyles",
        enabled: true,
        phase: "write",
        fn: applyStyles,
        effect: effect$1,
        requires: ["computeStyles"]
      };
      function distanceAndSkiddingToXY(placement, rects, offset2) {
        var basePlacement = getBasePlacement(placement);
        var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
        var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
          placement
        })) : offset2, skidding = _ref[0], distance = _ref[1];
        skidding = skidding || 0;
        distance = (distance || 0) * invertDistance;
        return [left, right].indexOf(basePlacement) >= 0 ? {
          x: distance,
          y: skidding
        } : {
          x: skidding,
          y: distance
        };
      }
      function offset(_ref2) {
        var state = _ref2.state, options = _ref2.options, name = _ref2.name;
        var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
        var data = placements.reduce(function(acc, placement) {
          acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
          return acc;
        }, {});
        var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
        if (state.modifiersData.popperOffsets != null) {
          state.modifiersData.popperOffsets.x += x;
          state.modifiersData.popperOffsets.y += y;
        }
        state.modifiersData[name] = data;
      }
      var offset$1 = {
        name: "offset",
        enabled: true,
        phase: "main",
        requires: ["popperOffsets"],
        fn: offset
      };
      var hash$1 = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
      };
      function getOppositePlacement(placement) {
        return placement.replace(/left|right|bottom|top/g, function(matched) {
          return hash$1[matched];
        });
      }
      var hash = {
        start: "end",
        end: "start"
      };
      function getOppositeVariationPlacement(placement) {
        return placement.replace(/start|end/g, function(matched) {
          return hash[matched];
        });
      }
      function computeAutoPlacement(state, options) {
        if (options === void 0) {
          options = {};
        }
        var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
        var variation = getVariation(placement);
        var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
          return getVariation(placement2) === variation;
        }) : basePlacements;
        var allowedPlacements = placements$1.filter(function(placement2) {
          return allowedAutoPlacements.indexOf(placement2) >= 0;
        });
        if (allowedPlacements.length === 0) {
          allowedPlacements = placements$1;
          if (true) {
            console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
          }
        }
        var overflows = allowedPlacements.reduce(function(acc, placement2) {
          acc[placement2] = detectOverflow(state, {
            placement: placement2,
            boundary,
            rootBoundary,
            padding
          })[getBasePlacement(placement2)];
          return acc;
        }, {});
        return Object.keys(overflows).sort(function(a, b) {
          return overflows[a] - overflows[b];
        });
      }
      function getExpandedFallbackPlacements(placement) {
        if (getBasePlacement(placement) === auto) {
          return [];
        }
        var oppositePlacement = getOppositePlacement(placement);
        return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
      }
      function flip(_ref) {
        var state = _ref.state, options = _ref.options, name = _ref.name;
        if (state.modifiersData[name]._skip) {
          return;
        }
        var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
        var preferredPlacement = state.options.placement;
        var basePlacement = getBasePlacement(preferredPlacement);
        var isBasePlacement = basePlacement === preferredPlacement;
        var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
        var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
          return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
            placement: placement2,
            boundary,
            rootBoundary,
            padding,
            flipVariations,
            allowedAutoPlacements
          }) : placement2);
        }, []);
        var referenceRect = state.rects.reference;
        var popperRect = state.rects.popper;
        var checksMap = /* @__PURE__ */ new Map();
        var makeFallbackChecks = true;
        var firstFittingPlacement = placements2[0];
        for (var i = 0; i < placements2.length; i++) {
          var placement = placements2[i];
          var _basePlacement = getBasePlacement(placement);
          var isStartVariation = getVariation(placement) === start;
          var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
          var len = isVertical ? "width" : "height";
          var overflow = detectOverflow(state, {
            placement,
            boundary,
            rootBoundary,
            altBoundary,
            padding
          });
          var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
          if (referenceRect[len] > popperRect[len]) {
            mainVariationSide = getOppositePlacement(mainVariationSide);
          }
          var altVariationSide = getOppositePlacement(mainVariationSide);
          var checks = [];
          if (checkMainAxis) {
            checks.push(overflow[_basePlacement] <= 0);
          }
          if (checkAltAxis) {
            checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
          }
          if (checks.every(function(check) {
            return check;
          })) {
            firstFittingPlacement = placement;
            makeFallbackChecks = false;
            break;
          }
          checksMap.set(placement, checks);
        }
        if (makeFallbackChecks) {
          var numberOfChecks = flipVariations ? 3 : 1;
          var _loop = function _loop2(_i2) {
            var fittingPlacement = placements2.find(function(placement2) {
              var checks2 = checksMap.get(placement2);
              if (checks2) {
                return checks2.slice(0, _i2).every(function(check) {
                  return check;
                });
              }
            });
            if (fittingPlacement) {
              firstFittingPlacement = fittingPlacement;
              return "break";
            }
          };
          for (var _i = numberOfChecks; _i > 0; _i--) {
            var _ret = _loop(_i);
            if (_ret === "break")
              break;
          }
        }
        if (state.placement !== firstFittingPlacement) {
          state.modifiersData[name]._skip = true;
          state.placement = firstFittingPlacement;
          state.reset = true;
        }
      }
      var flip$1 = {
        name: "flip",
        enabled: true,
        phase: "main",
        fn: flip,
        requiresIfExists: ["offset"],
        data: {
          _skip: false
        }
      };
      function getAltAxis(axis) {
        return axis === "x" ? "y" : "x";
      }
      function within(min$1, value, max$1) {
        return max(min$1, min(value, max$1));
      }
      function withinMaxClamp(min2, value, max2) {
        var v = within(min2, value, max2);
        return v > max2 ? max2 : v;
      }
      function preventOverflow(_ref) {
        var state = _ref.state, options = _ref.options, name = _ref.name;
        var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
        var overflow = detectOverflow(state, {
          boundary,
          rootBoundary,
          padding,
          altBoundary
        });
        var basePlacement = getBasePlacement(state.placement);
        var variation = getVariation(state.placement);
        var isBasePlacement = !variation;
        var mainAxis = getMainAxisFromPlacement(basePlacement);
        var altAxis = getAltAxis(mainAxis);
        var popperOffsets2 = state.modifiersData.popperOffsets;
        var referenceRect = state.rects.reference;
        var popperRect = state.rects.popper;
        var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
          placement: state.placement
        })) : tetherOffset;
        var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
          mainAxis: tetherOffsetValue,
          altAxis: tetherOffsetValue
        } : Object.assign({
          mainAxis: 0,
          altAxis: 0
        }, tetherOffsetValue);
        var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
        var data = {
          x: 0,
          y: 0
        };
        if (!popperOffsets2) {
          return;
        }
        if (checkMainAxis) {
          var _offsetModifierState$;
          var mainSide = mainAxis === "y" ? top : left;
          var altSide = mainAxis === "y" ? bottom : right;
          var len = mainAxis === "y" ? "height" : "width";
          var offset2 = popperOffsets2[mainAxis];
          var min$1 = offset2 + overflow[mainSide];
          var max$1 = offset2 - overflow[altSide];
          var additive = tether ? -popperRect[len] / 2 : 0;
          var minLen = variation === start ? referenceRect[len] : popperRect[len];
          var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
          var arrowElement = state.elements.arrow;
          var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
            width: 0,
            height: 0
          };
          var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
          var arrowPaddingMin = arrowPaddingObject[mainSide];
          var arrowPaddingMax = arrowPaddingObject[altSide];
          var arrowLen = within(0, referenceRect[len], arrowRect[len]);
          var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
          var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
          var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
          var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
          var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
          var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
          var tetherMax = offset2 + maxOffset - offsetModifierValue;
          var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
          popperOffsets2[mainAxis] = preventedOffset;
          data[mainAxis] = preventedOffset - offset2;
        }
        if (checkAltAxis) {
          var _offsetModifierState$2;
          var _mainSide = mainAxis === "x" ? top : left;
          var _altSide = mainAxis === "x" ? bottom : right;
          var _offset = popperOffsets2[altAxis];
          var _len = altAxis === "y" ? "height" : "width";
          var _min = _offset + overflow[_mainSide];
          var _max = _offset - overflow[_altSide];
          var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
          var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
          var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
          var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
          var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
          popperOffsets2[altAxis] = _preventedOffset;
          data[altAxis] = _preventedOffset - _offset;
        }
        state.modifiersData[name] = data;
      }
      var preventOverflow$1 = {
        name: "preventOverflow",
        enabled: true,
        phase: "main",
        fn: preventOverflow,
        requiresIfExists: ["offset"]
      };
      var toPaddingObject = function toPaddingObject2(padding, state) {
        padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
          placement: state.placement
        })) : padding;
        return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
      };
      function arrow(_ref) {
        var _state$modifiersData$;
        var state = _ref.state, name = _ref.name, options = _ref.options;
        var arrowElement = state.elements.arrow;
        var popperOffsets2 = state.modifiersData.popperOffsets;
        var basePlacement = getBasePlacement(state.placement);
        var axis = getMainAxisFromPlacement(basePlacement);
        var isVertical = [left, right].indexOf(basePlacement) >= 0;
        var len = isVertical ? "height" : "width";
        if (!arrowElement || !popperOffsets2) {
          return;
        }
        var paddingObject = toPaddingObject(options.padding, state);
        var arrowRect = getLayoutRect(arrowElement);
        var minProp = axis === "y" ? top : left;
        var maxProp = axis === "y" ? bottom : right;
        var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
        var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
        var arrowOffsetParent = getOffsetParent(arrowElement);
        var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
        var centerToReference = endDiff / 2 - startDiff / 2;
        var min2 = paddingObject[minProp];
        var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
        var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
        var offset2 = within(min2, center, max2);
        var axisProp = axis;
        state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
      }
      function effect(_ref2) {
        var state = _ref2.state, options = _ref2.options;
        var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
        if (arrowElement == null) {
          return;
        }
        if (typeof arrowElement === "string") {
          arrowElement = state.elements.popper.querySelector(arrowElement);
          if (!arrowElement) {
            return;
          }
        }
        if (true) {
          if (!isHTMLElement(arrowElement)) {
            console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
          }
        }
        if (!contains(state.elements.popper, arrowElement)) {
          if (true) {
            console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
          }
          return;
        }
        state.elements.arrow = arrowElement;
      }
      var arrow$1 = {
        name: "arrow",
        enabled: true,
        phase: "main",
        fn: arrow,
        effect,
        requires: ["popperOffsets"],
        requiresIfExists: ["preventOverflow"]
      };
      function getSideOffsets(overflow, rect, preventedOffsets) {
        if (preventedOffsets === void 0) {
          preventedOffsets = {
            x: 0,
            y: 0
          };
        }
        return {
          top: overflow.top - rect.height - preventedOffsets.y,
          right: overflow.right - rect.width + preventedOffsets.x,
          bottom: overflow.bottom - rect.height + preventedOffsets.y,
          left: overflow.left - rect.width - preventedOffsets.x
        };
      }
      function isAnySideFullyClipped(overflow) {
        return [top, right, bottom, left].some(function(side) {
          return overflow[side] >= 0;
        });
      }
      function hide(_ref) {
        var state = _ref.state, name = _ref.name;
        var referenceRect = state.rects.reference;
        var popperRect = state.rects.popper;
        var preventedOffsets = state.modifiersData.preventOverflow;
        var referenceOverflow = detectOverflow(state, {
          elementContext: "reference"
        });
        var popperAltOverflow = detectOverflow(state, {
          altBoundary: true
        });
        var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
        var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
        var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
        var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
        state.modifiersData[name] = {
          referenceClippingOffsets,
          popperEscapeOffsets,
          isReferenceHidden,
          hasPopperEscaped
        };
        state.attributes.popper = Object.assign({}, state.attributes.popper, {
          "data-popper-reference-hidden": isReferenceHidden,
          "data-popper-escaped": hasPopperEscaped
        });
      }
      var hide$1 = {
        name: "hide",
        enabled: true,
        phase: "main",
        requiresIfExists: ["preventOverflow"],
        fn: hide
      };
      var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
      var createPopper$1 = /* @__PURE__ */ popperGenerator({
        defaultModifiers: defaultModifiers$1
      });
      var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
      var createPopper2 = /* @__PURE__ */ popperGenerator({
        defaultModifiers
      });
      exports.applyStyles = applyStyles$1;
      exports.arrow = arrow$1;
      exports.computeStyles = computeStyles$1;
      exports.createPopper = createPopper2;
      exports.createPopperLite = createPopper$1;
      exports.defaultModifiers = defaultModifiers;
      exports.detectOverflow = detectOverflow;
      exports.eventListeners = eventListeners;
      exports.flip = flip$1;
      exports.hide = hide$1;
      exports.offset = offset$1;
      exports.popperGenerator = popperGenerator;
      exports.popperOffsets = popperOffsets$1;
      exports.preventOverflow = preventOverflow$1;
    }
  });

  // ns-hugo:/tmp/hugo_cache/modules/filecache/modules/pkg/mod/github.com/twbs/bootstrap@v5.3.2+incompatible/js/src/dom/data.js
  var elementMap = /* @__PURE__ */ new Map();
  var data_default = {
    set(element, key, instance) {
      if (!elementMap.has(element)) {
        elementMap.set(element, /* @__PURE__ */ new Map());
      }
      const instanceMap = elementMap.get(element);
      if (!instanceMap.has(key) && instanceMap.size !== 0) {
        console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
        return;
      }
      instanceMap.set(key, instance);
    },
    get(element, key) {
      if (elementMap.has(element)) {
        return elementMap.get(element).get(key) || null;
      }
      return null;
    },
    remove(element, key) {
      if (!elementMap.has(element)) {
        return;
      }
      const instanceMap = elementMap.get(element);
      instanceMap.delete(key);
      if (instanceMap.size === 0) {
        elementMap.delete(element);
      }
    }
  };

  // ns-hugo:/tmp/hugo_cache/modules/filecache/modules/pkg/mod/github.com/twbs/bootstrap@v5.3.2+incompatible/js/src/util/index.js
  var MILLISECONDS_MULTIPLIER = 1e3;
  var TRANSITION_END = "transitionend";
  var parseSelector = (selector) => {
    if (selector && window.CSS && window.CSS.escape) {
      selector = selector.replace(/#([^\s"#']+)/g, (match, id) => `#${CSS.escape(id)}`);
    }
    return selector;
  };
  var toType = (object) => {
    if (object === null || object === void 0) {
      return `${object}`;
    }
    return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
  };
  var getTransitionDurationFromElement = (element) => {
    if (!element) {
      return 0;
    }
    let { transitionDuration, transitionDelay } = window.getComputedStyle(element);
    const floatTransitionDuration = Number.parseFloat(transitionDuration);
    const floatTransitionDelay = Number.parseFloat(transitionDelay);
    if (!floatTransitionDuration && !floatTransitionDelay) {
      return 0;
    }
    transitionDuration = transitionDuration.split(",")[0];
    transitionDelay = transitionDelay.split(",")[0];
    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
  };
  var triggerTransitionEnd = (element) => {
    element.dispatchEvent(new Event(TRANSITION_END));
  };
  var isElement = (object) => {
    if (!object || typeof object !== "object") {
      return false;
    }
    if (typeof object.jquery !== "undefined") {
      object = object[0];
    }
    return typeof object.nodeType !== "undefined";
  };
  var getElement = (object) => {
    if (isElement(object)) {
      return object.jquery ? object[0] : object;
    }
    if (typeof object === "string" && object.length > 0) {
      return document.querySelector(parseSelector(object));
    }
    return null;
  };
  var isVisible = (element) => {
    if (!isElement(element) || element.getClientRects().length === 0) {
      return false;
    }
    const elementIsVisible = getComputedStyle(element).getPropertyValue("visibility") === "visible";
    const closedDetails = element.closest("details:not([open])");
    if (!closedDetails) {
      return elementIsVisible;
    }
    if (closedDetails !== element) {
      const summary = element.closest("summary");
      if (summary && summary.parentNode !== closedDetails) {
        return false;
      }
      if (summary === null) {
        return false;
      }
    }
    return elementIsVisible;
  };
  var isDisabled = (element) => {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }
    if (element.classList.contains("disabled")) {
      return true;
    }
    if (typeof element.disabled !== "undefined") {
      return element.disabled;
    }
    return element.hasAttribute("disabled") && element.getAttribute("disabled") !== "false";
  };
  var noop = () => {
  };
  var reflow = (element) => {
    element.offsetHeight;
  };
  var getjQuery = () => {
    if (window.jQuery && !document.body.hasAttribute("data-bs-no-jquery")) {
      return window.jQuery;
    }
    return null;
  };
  var DOMContentLoadedCallbacks = [];
  var onDOMContentLoaded = (callback) => {
    if (document.readyState === "loading") {
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener("DOMContentLoaded", () => {
          for (const callback2 of DOMContentLoadedCallbacks) {
            callback2();
          }
        });
      }
      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };
  var isRTL = () => document.documentElement.dir === "rtl";
  var defineJQueryPlugin = (plugin) => {
    onDOMContentLoaded(() => {
      const $ = getjQuery();
      if ($) {
        const name = plugin.NAME;
        const JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;
        $.fn[name].noConflict = () => {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };
  var execute = (possibleCallback, args = [], defaultValue = possibleCallback) => {
    return typeof possibleCallback === "function" ? possibleCallback(...args) : defaultValue;
  };
  var executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
    if (!waitForTransition) {
      execute(callback);
      return;
    }
    const durationPadding = 5;
    const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
    let called = false;
    const handler = ({ target }) => {
      if (target !== transitionElement) {
        return;
      }
      called = true;
      transitionElement.removeEventListener(TRANSITION_END, handler);
      execute(callback);
    };
    transitionElement.addEventListener(TRANSITION_END, handler);
    setTimeout(() => {
      if (!called) {
        triggerTransitionEnd(transitionElement);
      }
    }, emulatedDuration);
  };
  var getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
    const listLength = list.length;
    let index = list.indexOf(activeElement);
    if (index === -1) {
      return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
    }
    index += shouldGetNext ? 1 : -1;
    if (isCycleAllowed) {
      index = (index + listLength) % listLength;
    }
    return list[Math.max(0, Math.min(index, listLength - 1))];
  };

  // ns-hugo:/tmp/hugo_cache/modules/filecache/modules/pkg/mod/github.com/twbs/bootstrap@v5.3.2+incompatible/js/src/dom/event-handler.js
  var namespaceRegex = /[^.]*(?=\..*)\.|.*/;
  var stripNameRegex = /\..*/;
  var stripUidRegex = /::\d+$/;
  var eventRegistry = {};
  var uidEvent = 1;
  var customEvents = {
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  };
  var nativeEvents = /* @__PURE__ */ new Set([
    "click",
    "dblclick",
    "mouseup",
    "mousedown",
    "contextmenu",
    "mousewheel",
    "DOMMouseScroll",
    "mouseover",
    "mouseout",
    "mousemove",
    "selectstart",
    "selectend",
    "keydown",
    "keypress",
    "keyup",
    "orientationchange",
    "touchstart",
    "touchmove",
    "touchend",
    "touchcancel",
    "pointerdown",
    "pointermove",
    "pointerup",
    "pointerleave",
    "pointercancel",
    "gesturestart",
    "gesturechange",
    "gestureend",
    "focus",
    "blur",
    "change",
    "reset",
    "select",
    "submit",
    "focusin",
    "focusout",
    "load",
    "unload",
    "beforeunload",
    "resize",
    "move",
    "DOMContentLoaded",
    "readystatechange",
    "error",
    "abort",
    "scroll"
  ]);
  function makeEventUid(element, uid) {
    return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
  }
  function getElementEvents(element) {
    const uid = makeEventUid(element);
    element.uidEvent = uid;
    eventRegistry[uid] = eventRegistry[uid] || {};
    return eventRegistry[uid];
  }
  function bootstrapHandler(element, fn) {
    return function handler(event) {
      hydrateObj(event, { delegateTarget: element });
      if (handler.oneOff) {
        EventHandler.off(element, event.type, fn);
      }
      return fn.apply(element, [event]);
    };
  }
  function bootstrapDelegationHandler(element, selector, fn) {
    return function handler(event) {
      const domElements = element.querySelectorAll(selector);
      for (let { target } = event; target && target !== this; target = target.parentNode) {
        for (const domElement of domElements) {
          if (domElement !== target) {
            continue;
          }
          hydrateObj(event, { delegateTarget: target });
          if (handler.oneOff) {
            EventHandler.off(element, event.type, selector, fn);
          }
          return fn.apply(target, [event]);
        }
      }
    };
  }
  function findHandler(events, callable, delegationSelector = null) {
    return Object.values(events).find((event) => event.callable === callable && event.delegationSelector === delegationSelector);
  }
  function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
    const isDelegated = typeof handler === "string";
    const callable = isDelegated ? delegationFunction : handler || delegationFunction;
    let typeEvent = getTypeEvent(originalTypeEvent);
    if (!nativeEvents.has(typeEvent)) {
      typeEvent = originalTypeEvent;
    }
    return [isDelegated, callable, typeEvent];
  }
  function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
    if (typeof originalTypeEvent !== "string" || !element) {
      return;
    }
    let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
    if (originalTypeEvent in customEvents) {
      const wrapFunction = (fn2) => {
        return function(event) {
          if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
            return fn2.call(this, event);
          }
        };
      };
      callable = wrapFunction(callable);
    }
    const events = getElementEvents(element);
    const handlers = events[typeEvent] || (events[typeEvent] = {});
    const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);
    if (previousFunction) {
      previousFunction.oneOff = previousFunction.oneOff && oneOff;
      return;
    }
    const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ""));
    const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
    fn.delegationSelector = isDelegated ? handler : null;
    fn.callable = callable;
    fn.oneOff = oneOff;
    fn.uidEvent = uid;
    handlers[uid] = fn;
    element.addEventListener(typeEvent, fn, isDelegated);
  }
  function removeHandler(element, events, typeEvent, handler, delegationSelector) {
    const fn = findHandler(events[typeEvent], handler, delegationSelector);
    if (!fn) {
      return;
    }
    element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
    delete events[typeEvent][fn.uidEvent];
  }
  function removeNamespacedHandlers(element, events, typeEvent, namespace) {
    const storeElementEvent = events[typeEvent] || {};
    for (const [handlerKey, event] of Object.entries(storeElementEvent)) {
      if (handlerKey.includes(namespace)) {
        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
      }
    }
  }
  function getTypeEvent(event) {
    event = event.replace(stripNameRegex, "");
    return customEvents[event] || event;
  }
  var EventHandler = {
    on(element, event, handler, delegationFunction) {
      addHandler(element, event, handler, delegationFunction, false);
    },
    one(element, event, handler, delegationFunction) {
      addHandler(element, event, handler, delegationFunction, true);
    },
    off(element, originalTypeEvent, handler, delegationFunction) {
      if (typeof originalTypeEvent !== "string" || !element) {
        return;
      }
      const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
      const inNamespace = typeEvent !== originalTypeEvent;
      const events = getElementEvents(element);
      const storeElementEvent = events[typeEvent] || {};
      const isNamespace = originalTypeEvent.startsWith(".");
      if (typeof callable !== "undefined") {
        if (!Object.keys(storeElementEvent).length) {
          return;
        }
        removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
        return;
      }
      if (isNamespace) {
        for (const elementEvent of Object.keys(events)) {
          removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
        }
      }
      for (const [keyHandlers, event] of Object.entries(storeElementEvent)) {
        const handlerKey = keyHandlers.replace(stripUidRegex, "");
        if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
          removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
        }
      }
    },
    trigger(element, event, args) {
      if (typeof event !== "string" || !element) {
        return null;
      }
      const $ = getjQuery();
      const typeEvent = getTypeEvent(event);
      const inNamespace = event !== typeEvent;
      let jQueryEvent = null;
      let bubbles = true;
      let nativeDispatch = true;
      let defaultPrevented = false;
      if (inNamespace && $) {
        jQueryEvent = $.Event(event, args);
        $(element).trigger(jQueryEvent);
        bubbles = !jQueryEvent.isPropagationStopped();
        nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
        defaultPrevented = jQueryEvent.isDefaultPrevented();
      }
      const evt = hydrateObj(new Event(event, { bubbles, cancelable: true }), args);
      if (defaultPrevented) {
        evt.preventDefault();
      }
      if (nativeDispatch) {
        element.dispatchEvent(evt);
      }
      if (evt.defaultPrevented && jQueryEvent) {
        jQueryEvent.preventDefault();
      }
      return evt;
    }
  };
  function hydrateObj(obj, meta = {}) {
    for (const [key, value] of Object.entries(meta)) {
      try {
        obj[key] = value;
      } catch (e) {
        Object.defineProperty(obj, key, {
          configurable: true,
          get() {
            return value;
          }
        });
      }
    }
    return obj;
  }
  var event_handler_default = EventHandler;

  // ns-hugo:/tmp/hugo_cache/modules/filecache/modules/pkg/mod/github.com/twbs/bootstrap@v5.3.2+incompatible/js/src/dom/manipulator.js
  function normalizeData(value) {
    if (value === "true") {
      return true;
    }
    if (value === "false") {
      return false;
    }
    if (value === Number(value).toString()) {
      return Number(value);
    }
    if (value === "" || value === "null") {
      return null;
    }
    if (typeof value !== "string") {
      return value;
    }
    try {
      return JSON.parse(decodeURIComponent(value));
    } catch (e) {
      return value;
    }
  }
  function normalizeDataKey(key) {
    return key.replace(/[A-Z]/g, (chr) => `-${chr.toLowerCase()}`);
  }
  var Manipulator = {
    setDataAttribute(element, key, value) {
      element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
    },
    removeDataAttribute(element, key) {
      element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
    },
    getDataAttributes(element) {
      if (!element) {
        return {};
      }
      const attributes = {};
      const bsKeys = Object.keys(element.dataset).filter((key) => key.startsWith("bs") && !key.startsWith("bsConfig"));
      for (const key of bsKeys) {
        let pureKey = key.replace(/^bs/, "");
        pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
        attributes[pureKey] = normalizeData(element.dataset[key]);
      }
      return attributes;
    },
    getDataAttribute(element, key) {
      return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
    }
  };
  var manipulator_default = Manipulator;

  // ns-hugo:/tmp/hugo_cache/modules/filecache/modules/pkg/mod/github.com/twbs/bootstrap@v5.3.2+incompatible/js/src/util/config.js
  var Config = class {
    // Getters
    static get Default() {
      return {};
    }
    static get DefaultType() {
      return {};
    }
    static get NAME() {
      throw new Error('You have to implement the static method "NAME", for each component!');
    }
    _getConfig(config) {
      config = this._mergeConfigObj(config);
      config = this._configAfterMerge(config);
      this._typeCheckConfig(config);
      return config;
    }
    _configAfterMerge(config) {
      return config;
    }
    _mergeConfigObj(config, element) {
      const jsonConfig = isElement(element) ? manipulator_default.getDataAttribute(element, "config") : {};
      return {
        ...this.constructor.Default,
        ...typeof jsonConfig === "object" ? jsonConfig : {},
        ...isElement(element) ? manipulator_default.getDataAttributes(element) : {},
        ...typeof config === "object" ? config : {}
      };
    }
    _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {
      for (const [property, expectedTypes] of Object.entries(configTypes)) {
        const value = config[property];
        const valueType = isElement(value) ? "element" : toType(value);
        if (!new RegExp(expectedTypes).test(valueType)) {
          throw new TypeError(
            `${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`
          );
        }
      }
    }
  };
  var config_default = Config;

  // ns-hugo:/tmp/hugo_cache/modules/filecache/modules/pkg/mod/github.com/twbs/bootstrap@v5.3.2+incompatible/js/src/base-component.js
  var VERSION = "5.3.2";
  var BaseComponent = class extends config_default {
    constructor(element, config) {
      super();
      element = getElement(element);
      if (!element) {
        return;
      }
      this._element = element;
      this._config = this._getConfig(config);
      data_default.set(this._element, this.constructor.DATA_KEY, this);
    }
    // Public
    dispose() {
      data_default.remove(this._element, this.constructor.DATA_KEY);
      event_handler_default.off(this._element, this.constructor.EVENT_KEY);
      for (const propertyName of Object.getOwnPropertyNames(this)) {
        this[propertyName] = null;
      }
    }
    _queueCallback(callback, element, isAnimated = true) {
      executeAfterTransition(callback, element, isAnimated);
    }
    _getConfig(config) {
      config = this._mergeConfigObj(config, this._element);
      config = this._configAfterMerge(config);
      this._typeCheckConfig(config);
      return config;
    }
    // Static
    static getInstance(element) {
      return data_default.get(getElement(element), this.DATA_KEY);
    }
    static getOrCreateInstance(element, config = {}) {
      return this.getInstance(element) || new this(element, typeof config === "object" ? config : null);
    }
    static get VERSION() {
      return VERSION;
    }
    static get DATA_KEY() {
      return `bs.${this.NAME}`;
    }
    static get EVENT_KEY() {
      return `.${this.DATA_KEY}`;
    }
    static eventName(name) {
      return `${name}${this.EVENT_KEY}`;
    }
  };
  var base_component_default = BaseComponent;

  // ns-hugo:/tmp/hugo_cache/modules/filecache/modules/pkg/mod/github.com/twbs/bootstrap@v5.3.2+incompatible/js/src/dom/selector-engine.js
  var getSelector = (element) => {
    let selector = element.getAttribute("data-bs-target");
    if (!selector || selector === "#") {
      let hrefAttribute = element.getAttribute("href");
      if (!hrefAttribute || !hrefAttribute.includes("#") && !hrefAttribute.startsWith(".")) {
        return null;
      }
      if (hrefAttribute.includes("#") && !hrefAttribute.startsWith("#")) {
        hrefAttribute = `#${hrefAttribute.split("#")[1]}`;
      }
      selector = hrefAttribute && hrefAttribute !== "#" ? parseSelector(hrefAttribute.trim()) : null;
    }
    return selector;
  };
  var SelectorEngine = {
    find(selector, element = document.documentElement) {
      return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
    },
    findOne(selector, element = document.documentElement) {
      return Element.prototype.querySelector.call(element, selector);
    },
    children(element, selector) {
      return [].concat(...element.children).filter((child) => child.matches(selector));
    },
    parents(element, selector) {
      const parents = [];
      let ancestor = element.parentNode.closest(selector);
      while (ancestor) {
        parents.push(ancestor);
        ancestor = ancestor.parentNode.closest(selector);
      }
      return parents;
    },
    prev(element, selector) {
      let previous = element.previousElementSibling;
      while (previous) {
        if (previous.matches(selector)) {
          return [previous];
        }
        previous = previous.previousElementSibling;
      }
      return [];
    },
    // TODO: this is now unused; remove later along with prev()
    next(element, selector) {
      let next = element.nextElementSibling;
      while (next) {
        if (next.matches(selector)) {
          return [next];
        }
        next = next.nextElementSibling;
      }
      return [];
    },
    focusableChildren(element) {
      const focusables = [
        "a",
        "button",
        "input",
        "textarea",
        "select",
        "details",
        "[tabindex]",
        '[contenteditable="true"]'
      ].map((selector) => `${selector}:not([tabindex^="-"])`).join(",");
      return this.find(focusables, element).filter((el) => !isDisabled(el) && isVisible(el));
    },
    getSelectorFromElement(element) {
      const selector = getSelector(element);
      if (selector) {
        return SelectorEngine.findOne(selector) ? selector : null;
      }
      return null;
    },
    getElementFromSelector(element) {
      const selector = getSelector(element);
      return selector ? SelectorEngine.findOne(selector) : null;
    },
    getMultipleElementsFromSelector(element) {
      const selector = getSelector(element);
      return selector ? SelectorEngine.find(selector) : [];
    }
  };
  var selector_engine_default = SelectorEngine;

  // ns-hugo:/tmp/hugo_cache/modules/filecache/modules/pkg/mod/github.com/twbs/bootstrap@v5.3.2+incompatible/js/src/collapse.js
  var NAME = "collapse";
  var DATA_KEY = "bs.collapse";
  var EVENT_KEY = `.${DATA_KEY}`;
  var DATA_API_KEY = ".data-api";
  var EVENT_SHOW = `show${EVENT_KEY}`;
  var EVENT_SHOWN = `shown${EVENT_KEY}`;
  var EVENT_HIDE = `hide${EVENT_KEY}`;
  var EVENT_HIDDEN = `hidden${EVENT_KEY}`;
  var EVENT_CLICK_DATA_API = `click${EVENT_KEY}${DATA_API_KEY}`;
  var CLASS_NAME_SHOW = "show";
  var CLASS_NAME_COLLAPSE = "collapse";
  var CLASS_NAME_COLLAPSING = "collapsing";
  var CLASS_NAME_COLLAPSED = "collapsed";
  var CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
  var CLASS_NAME_HORIZONTAL = "collapse-horizontal";
  var WIDTH = "width";
  var HEIGHT = "height";
  var SELECTOR_ACTIVES = ".collapse.show, .collapse.collapsing";
  var SELECTOR_DATA_TOGGLE = '[data-bs-toggle="collapse"]';
  var Default = {
    parent: null,
    toggle: true
  };
  var DefaultType = {
    parent: "(null|element)",
    toggle: "boolean"
  };
  var Collapse = class _Collapse extends base_component_default {
    constructor(element, config) {
      super(element, config);
      this._isTransitioning = false;
      this._triggerArray = [];
      const toggleList = selector_engine_default.find(SELECTOR_DATA_TOGGLE);
      for (const elem of toggleList) {
        const selector = selector_engine_default.getSelectorFromElement(elem);
        const filterElement = selector_engine_default.find(selector).filter((foundElement) => foundElement === this._element);
        if (selector !== null && filterElement.length) {
          this._triggerArray.push(elem);
        }
      }
      this._initializeChildren();
      if (!this._config.parent) {
        this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
      }
      if (this._config.toggle) {
        this.toggle();
      }
    }
    // Getters
    static get Default() {
      return Default;
    }
    static get DefaultType() {
      return DefaultType;
    }
    static get NAME() {
      return NAME;
    }
    // Public
    toggle() {
      if (this._isShown()) {
        this.hide();
      } else {
        this.show();
      }
    }
    show() {
      if (this._isTransitioning || this._isShown()) {
        return;
      }
      let activeChildren = [];
      if (this._config.parent) {
        activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter((element) => element !== this._element).map((element) => _Collapse.getOrCreateInstance(element, { toggle: false }));
      }
      if (activeChildren.length && activeChildren[0]._isTransitioning) {
        return;
      }
      const startEvent = event_handler_default.trigger(this._element, EVENT_SHOW);
      if (startEvent.defaultPrevented) {
        return;
      }
      for (const activeInstance of activeChildren) {
        activeInstance.hide();
      }
      const dimension = this._getDimension();
      this._element.classList.remove(CLASS_NAME_COLLAPSE);
      this._element.classList.add(CLASS_NAME_COLLAPSING);
      this._element.style[dimension] = 0;
      this._addAriaAndCollapsedClass(this._triggerArray, true);
      this._isTransitioning = true;
      const complete = () => {
        this._isTransitioning = false;
        this._element.classList.remove(CLASS_NAME_COLLAPSING);
        this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW);
        this._element.style[dimension] = "";
        event_handler_default.trigger(this._element, EVENT_SHOWN);
      };
      const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
      const scrollSize = `scroll${capitalizedDimension}`;
      this._queueCallback(complete, this._element, true);
      this._element.style[dimension] = `${this._element[scrollSize]}px`;
    }
    hide() {
      if (this._isTransitioning || !this._isShown()) {
        return;
      }
      const startEvent = event_handler_default.trigger(this._element, EVENT_HIDE);
      if (startEvent.defaultPrevented) {
        return;
      }
      const dimension = this._getDimension();
      this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_COLLAPSING);
      this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW);
      for (const trigger of this._triggerArray) {
        const element = selector_engine_default.getElementFromSelector(trigger);
        if (element && !this._isShown(element)) {
          this._addAriaAndCollapsedClass([trigger], false);
        }
      }
      this._isTransitioning = true;
      const complete = () => {
        this._isTransitioning = false;
        this._element.classList.remove(CLASS_NAME_COLLAPSING);
        this._element.classList.add(CLASS_NAME_COLLAPSE);
        event_handler_default.trigger(this._element, EVENT_HIDDEN);
      };
      this._element.style[dimension] = "";
      this._queueCallback(complete, this._element, true);
    }
    _isShown(element = this._element) {
      return element.classList.contains(CLASS_NAME_SHOW);
    }
    // Private
    _configAfterMerge(config) {
      config.toggle = Boolean(config.toggle);
      config.parent = getElement(config.parent);
      return config;
    }
    _getDimension() {
      return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
    }
    _initializeChildren() {
      if (!this._config.parent) {
        return;
      }
      const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE);
      for (const element of children) {
        const selected = selector_engine_default.getElementFromSelector(element);
        if (selected) {
          this._addAriaAndCollapsedClass([element], this._isShown(selected));
        }
      }
    }
    _getFirstLevelChildren(selector) {
      const children = selector_engine_default.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
      return selector_engine_default.find(selector, this._config.parent).filter((element) => !children.includes(element));
    }
    _addAriaAndCollapsedClass(triggerArray, isOpen) {
      if (!triggerArray.length) {
        return;
      }
      for (const element of triggerArray) {
        element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
        element.setAttribute("aria-expanded", isOpen);
      }
    }
    // Static
    static jQueryInterface(config) {
      const _config = {};
      if (typeof config === "string" && /show|hide/.test(config)) {
        _config.toggle = false;
      }
      return this.each(function() {
        const data = _Collapse.getOrCreateInstance(this, _config);
        if (typeof config === "string") {
          if (typeof data[config] === "undefined") {
            throw new TypeError(`No method named "${config}"`);
          }
          data[config]();
        }
      });
    }
  };
  event_handler_default.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
    if (event.target.tagName === "A" || event.delegateTarget && event.delegateTarget.tagName === "A") {
      event.preventDefault();
    }
    for (const element of selector_engine_default.getMultipleElementsFromSelector(this)) {
      Collapse.getOrCreateInstance(element, { toggle: false }).toggle();
    }
  });
  defineJQueryPlugin(Collapse);

  // ns-hugo:/tmp/hugo_cache/modules/filecache/modules/pkg/mod/github.com/twbs/bootstrap@v5.3.2+incompatible/js/src/dropdown.js
  var Popper = __toESM(require_popper());
  var NAME2 = "dropdown";
  var DATA_KEY2 = "bs.dropdown";
  var EVENT_KEY2 = `.${DATA_KEY2}`;
  var DATA_API_KEY2 = ".data-api";
  var ESCAPE_KEY = "Escape";
  var TAB_KEY = "Tab";
  var ARROW_UP_KEY = "ArrowUp";
  var ARROW_DOWN_KEY = "ArrowDown";
  var RIGHT_MOUSE_BUTTON = 2;
  var EVENT_HIDE2 = `hide${EVENT_KEY2}`;
  var EVENT_HIDDEN2 = `hidden${EVENT_KEY2}`;
  var EVENT_SHOW2 = `show${EVENT_KEY2}`;
  var EVENT_SHOWN2 = `shown${EVENT_KEY2}`;
  var EVENT_CLICK_DATA_API2 = `click${EVENT_KEY2}${DATA_API_KEY2}`;
  var EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY2}${DATA_API_KEY2}`;
  var EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY2}${DATA_API_KEY2}`;
  var CLASS_NAME_SHOW2 = "show";
  var CLASS_NAME_DROPUP = "dropup";
  var CLASS_NAME_DROPEND = "dropend";
  var CLASS_NAME_DROPSTART = "dropstart";
  var CLASS_NAME_DROPUP_CENTER = "dropup-center";
  var CLASS_NAME_DROPDOWN_CENTER = "dropdown-center";
  var SELECTOR_DATA_TOGGLE2 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
  var SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE2}.${CLASS_NAME_SHOW2}`;
  var SELECTOR_MENU = ".dropdown-menu";
  var SELECTOR_NAVBAR = ".navbar";
  var SELECTOR_NAVBAR_NAV = ".navbar-nav";
  var SELECTOR_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
  var PLACEMENT_TOP = isRTL() ? "top-end" : "top-start";
  var PLACEMENT_TOPEND = isRTL() ? "top-start" : "top-end";
  var PLACEMENT_BOTTOM = isRTL() ? "bottom-end" : "bottom-start";
  var PLACEMENT_BOTTOMEND = isRTL() ? "bottom-start" : "bottom-end";
  var PLACEMENT_RIGHT = isRTL() ? "left-start" : "right-start";
  var PLACEMENT_LEFT = isRTL() ? "right-start" : "left-start";
  var PLACEMENT_TOPCENTER = "top";
  var PLACEMENT_BOTTOMCENTER = "bottom";
  var Default2 = {
    autoClose: true,
    boundary: "clippingParents",
    display: "dynamic",
    offset: [0, 2],
    popperConfig: null,
    reference: "toggle"
  };
  var DefaultType2 = {
    autoClose: "(boolean|string)",
    boundary: "(string|element)",
    display: "string",
    offset: "(array|string|function)",
    popperConfig: "(null|object|function)",
    reference: "(string|element|object)"
  };
  var Dropdown = class _Dropdown extends base_component_default {
    constructor(element, config) {
      super(element, config);
      this._popper = null;
      this._parent = this._element.parentNode;
      this._menu = selector_engine_default.next(this._element, SELECTOR_MENU)[0] || selector_engine_default.prev(this._element, SELECTOR_MENU)[0] || selector_engine_default.findOne(SELECTOR_MENU, this._parent);
      this._inNavbar = this._detectNavbar();
    }
    // Getters
    static get Default() {
      return Default2;
    }
    static get DefaultType() {
      return DefaultType2;
    }
    static get NAME() {
      return NAME2;
    }
    // Public
    toggle() {
      return this._isShown() ? this.hide() : this.show();
    }
    show() {
      if (isDisabled(this._element) || this._isShown()) {
        return;
      }
      const relatedTarget = {
        relatedTarget: this._element
      };
      const showEvent = event_handler_default.trigger(this._element, EVENT_SHOW2, relatedTarget);
      if (showEvent.defaultPrevented) {
        return;
      }
      this._createPopper();
      if ("ontouchstart" in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {
        for (const element of [].concat(...document.body.children)) {
          event_handler_default.on(element, "mouseover", noop);
        }
      }
      this._element.focus();
      this._element.setAttribute("aria-expanded", true);
      this._menu.classList.add(CLASS_NAME_SHOW2);
      this._element.classList.add(CLASS_NAME_SHOW2);
      event_handler_default.trigger(this._element, EVENT_SHOWN2, relatedTarget);
    }
    hide() {
      if (isDisabled(this._element) || !this._isShown()) {
        return;
      }
      const relatedTarget = {
        relatedTarget: this._element
      };
      this._completeHide(relatedTarget);
    }
    dispose() {
      if (this._popper) {
        this._popper.destroy();
      }
      super.dispose();
    }
    update() {
      this._inNavbar = this._detectNavbar();
      if (this._popper) {
        this._popper.update();
      }
    }
    // Private
    _completeHide(relatedTarget) {
      const hideEvent = event_handler_default.trigger(this._element, EVENT_HIDE2, relatedTarget);
      if (hideEvent.defaultPrevented) {
        return;
      }
      if ("ontouchstart" in document.documentElement) {
        for (const element of [].concat(...document.body.children)) {
          event_handler_default.off(element, "mouseover", noop);
        }
      }
      if (this._popper) {
        this._popper.destroy();
      }
      this._menu.classList.remove(CLASS_NAME_SHOW2);
      this._element.classList.remove(CLASS_NAME_SHOW2);
      this._element.setAttribute("aria-expanded", "false");
      manipulator_default.removeDataAttribute(this._menu, "popper");
      event_handler_default.trigger(this._element, EVENT_HIDDEN2, relatedTarget);
    }
    _getConfig(config) {
      config = super._getConfig(config);
      if (typeof config.reference === "object" && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== "function") {
        throw new TypeError(`${NAME2.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
      }
      return config;
    }
    _createPopper() {
      if (typeof Popper === "undefined") {
        throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
      }
      let referenceElement = this._element;
      if (this._config.reference === "parent") {
        referenceElement = this._parent;
      } else if (isElement(this._config.reference)) {
        referenceElement = getElement(this._config.reference);
      } else if (typeof this._config.reference === "object") {
        referenceElement = this._config.reference;
      }
      const popperConfig = this._getPopperConfig();
      this._popper = Popper.createPopper(referenceElement, this._menu, popperConfig);
    }
    _isShown() {
      return this._menu.classList.contains(CLASS_NAME_SHOW2);
    }
    _getPlacement() {
      const parentDropdown = this._parent;
      if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
        return PLACEMENT_RIGHT;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
        return PLACEMENT_LEFT;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {
        return PLACEMENT_TOPCENTER;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {
        return PLACEMENT_BOTTOMCENTER;
      }
      const isEnd = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
        return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
      }
      return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
    }
    _detectNavbar() {
      return this._element.closest(SELECTOR_NAVBAR) !== null;
    }
    _getOffset() {
      const { offset } = this._config;
      if (typeof offset === "string") {
        return offset.split(",").map((value) => Number.parseInt(value, 10));
      }
      if (typeof offset === "function") {
        return (popperData) => offset(popperData, this._element);
      }
      return offset;
    }
    _getPopperConfig() {
      const defaultBsPopperConfig = {
        placement: this._getPlacement(),
        modifiers: [
          {
            name: "preventOverflow",
            options: {
              boundary: this._config.boundary
            }
          },
          {
            name: "offset",
            options: {
              offset: this._getOffset()
            }
          }
        ]
      };
      if (this._inNavbar || this._config.display === "static") {
        manipulator_default.setDataAttribute(this._menu, "popper", "static");
        defaultBsPopperConfig.modifiers = [{
          name: "applyStyles",
          enabled: false
        }];
      }
      return {
        ...defaultBsPopperConfig,
        ...execute(this._config.popperConfig, [defaultBsPopperConfig])
      };
    }
    _selectMenuItem({ key, target }) {
      const items = selector_engine_default.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter((element) => isVisible(element));
      if (!items.length) {
        return;
      }
      getNextActiveElement(items, target, key === ARROW_DOWN_KEY, !items.includes(target)).focus();
    }
    // Static
    static jQueryInterface(config) {
      return this.each(function() {
        const data = _Dropdown.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
    static clearMenus(event) {
      if (event.button === RIGHT_MOUSE_BUTTON || event.type === "keyup" && event.key !== TAB_KEY) {
        return;
      }
      const openToggles = selector_engine_default.find(SELECTOR_DATA_TOGGLE_SHOWN);
      for (const toggle of openToggles) {
        const context = _Dropdown.getInstance(toggle);
        if (!context || context._config.autoClose === false) {
          continue;
        }
        const composedPath = event.composedPath();
        const isMenuTarget = composedPath.includes(context._menu);
        if (composedPath.includes(context._element) || context._config.autoClose === "inside" && !isMenuTarget || context._config.autoClose === "outside" && isMenuTarget) {
          continue;
        }
        if (context._menu.contains(event.target) && (event.type === "keyup" && event.key === TAB_KEY || /input|select|option|textarea|form/i.test(event.target.tagName))) {
          continue;
        }
        const relatedTarget = { relatedTarget: context._element };
        if (event.type === "click") {
          relatedTarget.clickEvent = event;
        }
        context._completeHide(relatedTarget);
      }
    }
    static dataApiKeydownHandler(event) {
      const isInput = /input|textarea/i.test(event.target.tagName);
      const isEscapeEvent = event.key === ESCAPE_KEY;
      const isUpOrDownEvent = [ARROW_UP_KEY, ARROW_DOWN_KEY].includes(event.key);
      if (!isUpOrDownEvent && !isEscapeEvent) {
        return;
      }
      if (isInput && !isEscapeEvent) {
        return;
      }
      event.preventDefault();
      const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE2) ? this : selector_engine_default.prev(this, SELECTOR_DATA_TOGGLE2)[0] || selector_engine_default.next(this, SELECTOR_DATA_TOGGLE2)[0] || selector_engine_default.findOne(SELECTOR_DATA_TOGGLE2, event.delegateTarget.parentNode);
      const instance = _Dropdown.getOrCreateInstance(getToggleButton);
      if (isUpOrDownEvent) {
        event.stopPropagation();
        instance.show();
        instance._selectMenuItem(event);
        return;
      }
      if (instance._isShown()) {
        event.stopPropagation();
        instance.hide();
        getToggleButton.focus();
      }
    }
  };
  event_handler_default.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE2, Dropdown.dataApiKeydownHandler);
  event_handler_default.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
  event_handler_default.on(document, EVENT_CLICK_DATA_API2, Dropdown.clearMenus);
  event_handler_default.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
  event_handler_default.on(document, EVENT_CLICK_DATA_API2, SELECTOR_DATA_TOGGLE2, function(event) {
    event.preventDefault();
    Dropdown.getOrCreateInstance(this).toggle();
  });
  defineJQueryPlugin(Dropdown);

  // ns-hugo:/tmp/hugo_cache/modules/filecache/modules/pkg/mod/github.com/twbs/bootstrap@v5.3.2+incompatible/js/src/util/backdrop.js
  var NAME3 = "backdrop";
  var CLASS_NAME_FADE = "fade";
  var CLASS_NAME_SHOW3 = "show";
  var EVENT_MOUSEDOWN = `mousedown.bs.${NAME3}`;
  var Default3 = {
    className: "modal-backdrop",
    clickCallback: null,
    isAnimated: false,
    isVisible: true,
    // if false, we use the backdrop helper without adding any element to the dom
    rootElement: "body"
    // give the choice to place backdrop under different elements
  };
  var DefaultType3 = {
    className: "string",
    clickCallback: "(function|null)",
    isAnimated: "boolean",
    isVisible: "boolean",
    rootElement: "(element|string)"
  };
  var Backdrop = class extends config_default {
    constructor(config) {
      super();
      this._config = this._getConfig(config);
      this._isAppended = false;
      this._element = null;
    }
    // Getters
    static get Default() {
      return Default3;
    }
    static get DefaultType() {
      return DefaultType3;
    }
    static get NAME() {
      return NAME3;
    }
    // Public
    show(callback) {
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }
      this._append();
      const element = this._getElement();
      if (this._config.isAnimated) {
        reflow(element);
      }
      element.classList.add(CLASS_NAME_SHOW3);
      this._emulateAnimation(() => {
        execute(callback);
      });
    }
    hide(callback) {
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }
      this._getElement().classList.remove(CLASS_NAME_SHOW3);
      this._emulateAnimation(() => {
        this.dispose();
        execute(callback);
      });
    }
    dispose() {
      if (!this._isAppended) {
        return;
      }
      event_handler_default.off(this._element, EVENT_MOUSEDOWN);
      this._element.remove();
      this._isAppended = false;
    }
    // Private
    _getElement() {
      if (!this._element) {
        const backdrop = document.createElement("div");
        backdrop.className = this._config.className;
        if (this._config.isAnimated) {
          backdrop.classList.add(CLASS_NAME_FADE);
        }
        this._element = backdrop;
      }
      return this._element;
    }
    _configAfterMerge(config) {
      config.rootElement = getElement(config.rootElement);
      return config;
    }
    _append() {
      if (this._isAppended) {
        return;
      }
      const element = this._getElement();
      this._config.rootElement.append(element);
      event_handler_default.on(element, EVENT_MOUSEDOWN, () => {
        execute(this._config.clickCallback);
      });
      this._isAppended = true;
    }
    _emulateAnimation(callback) {
      executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
    }
  };
  var backdrop_default = Backdrop;

  // ns-hugo:/tmp/hugo_cache/modules/filecache/modules/pkg/mod/github.com/twbs/bootstrap@v5.3.2+incompatible/js/src/util/component-functions.js
  var enableDismissTrigger = (component, method = "hide") => {
    const clickEvent = `click.dismiss${component.EVENT_KEY}`;
    const name = component.NAME;
    event_handler_default.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function(event) {
      if (["A", "AREA"].includes(this.tagName)) {
        event.preventDefault();
      }
      if (isDisabled(this)) {
        return;
      }
      const target = selector_engine_default.getElementFromSelector(this) || this.closest(`.${name}`);
      const instance = component.getOrCreateInstance(target);
      instance[method]();
    });
  };

  // ns-hugo:/tmp/hugo_cache/modules/filecache/modules/pkg/mod/github.com/twbs/bootstrap@v5.3.2+incompatible/js/src/util/focustrap.js
  var NAME4 = "focustrap";
  var DATA_KEY3 = "bs.focustrap";
  var EVENT_KEY3 = `.${DATA_KEY3}`;
  var EVENT_FOCUSIN = `focusin${EVENT_KEY3}`;
  var EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY3}`;
  var TAB_KEY2 = "Tab";
  var TAB_NAV_FORWARD = "forward";
  var TAB_NAV_BACKWARD = "backward";
  var Default4 = {
    autofocus: true,
    trapElement: null
    // The element to trap focus inside of
  };
  var DefaultType4 = {
    autofocus: "boolean",
    trapElement: "element"
  };
  var FocusTrap = class extends config_default {
    constructor(config) {
      super();
      this._config = this._getConfig(config);
      this._isActive = false;
      this._lastTabNavDirection = null;
    }
    // Getters
    static get Default() {
      return Default4;
    }
    static get DefaultType() {
      return DefaultType4;
    }
    static get NAME() {
      return NAME4;
    }
    // Public
    activate() {
      if (this._isActive) {
        return;
      }
      if (this._config.autofocus) {
        this._config.trapElement.focus();
      }
      event_handler_default.off(document, EVENT_KEY3);
      event_handler_default.on(document, EVENT_FOCUSIN, (event) => this._handleFocusin(event));
      event_handler_default.on(document, EVENT_KEYDOWN_TAB, (event) => this._handleKeydown(event));
      this._isActive = true;
    }
    deactivate() {
      if (!this._isActive) {
        return;
      }
      this._isActive = false;
      event_handler_default.off(document, EVENT_KEY3);
    }
    // Private
    _handleFocusin(event) {
      const { trapElement } = this._config;
      if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {
        return;
      }
      const elements = selector_engine_default.focusableChildren(trapElement);
      if (elements.length === 0) {
        trapElement.focus();
      } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
        elements[elements.length - 1].focus();
      } else {
        elements[0].focus();
      }
    }
    _handleKeydown(event) {
      if (event.key !== TAB_KEY2) {
        return;
      }
      this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
    }
  };
  var focustrap_default = FocusTrap;

  // ns-hugo:/tmp/hugo_cache/modules/filecache/modules/pkg/mod/github.com/twbs/bootstrap@v5.3.2+incompatible/js/src/util/scrollbar.js
  var SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
  var SELECTOR_STICKY_CONTENT = ".sticky-top";
  var PROPERTY_PADDING = "padding-right";
  var PROPERTY_MARGIN = "margin-right";
  var ScrollBarHelper = class {
    constructor() {
      this._element = document.body;
    }
    // Public
    getWidth() {
      const documentWidth = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - documentWidth);
    }
    hide() {
      const width = this.getWidth();
      this._disableOverFlow();
      this._setElementAttributes(this._element, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width);
      this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width);
      this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, (calculatedValue) => calculatedValue - width);
    }
    reset() {
      this._resetElementAttributes(this._element, "overflow");
      this._resetElementAttributes(this._element, PROPERTY_PADDING);
      this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
      this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
    }
    isOverflowing() {
      return this.getWidth() > 0;
    }
    // Private
    _disableOverFlow() {
      this._saveInitialAttribute(this._element, "overflow");
      this._element.style.overflow = "hidden";
    }
    _setElementAttributes(selector, styleProperty, callback) {
      const scrollbarWidth = this.getWidth();
      const manipulationCallBack = (element) => {
        if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
          return;
        }
        this._saveInitialAttribute(element, styleProperty);
        const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
        element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);
      };
      this._applyManipulationCallback(selector, manipulationCallBack);
    }
    _saveInitialAttribute(element, styleProperty) {
      const actualValue = element.style.getPropertyValue(styleProperty);
      if (actualValue) {
        manipulator_default.setDataAttribute(element, styleProperty, actualValue);
      }
    }
    _resetElementAttributes(selector, styleProperty) {
      const manipulationCallBack = (element) => {
        const value = manipulator_default.getDataAttribute(element, styleProperty);
        if (value === null) {
          element.style.removeProperty(styleProperty);
          return;
        }
        manipulator_default.removeDataAttribute(element, styleProperty);
        element.style.setProperty(styleProperty, value);
      };
      this._applyManipulationCallback(selector, manipulationCallBack);
    }
    _applyManipulationCallback(selector, callBack) {
      if (isElement(selector)) {
        callBack(selector);
        return;
      }
      for (const sel of selector_engine_default.find(selector, this._element)) {
        callBack(sel);
      }
    }
  };
  var scrollbar_default = ScrollBarHelper;

  // ns-hugo:/tmp/hugo_cache/modules/filecache/modules/pkg/mod/github.com/twbs/bootstrap@v5.3.2+incompatible/js/src/modal.js
  var NAME5 = "modal";
  var DATA_KEY4 = "bs.modal";
  var EVENT_KEY4 = `.${DATA_KEY4}`;
  var DATA_API_KEY3 = ".data-api";
  var ESCAPE_KEY2 = "Escape";
  var EVENT_HIDE3 = `hide${EVENT_KEY4}`;
  var EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY4}`;
  var EVENT_HIDDEN3 = `hidden${EVENT_KEY4}`;
  var EVENT_SHOW3 = `show${EVENT_KEY4}`;
  var EVENT_SHOWN3 = `shown${EVENT_KEY4}`;
  var EVENT_RESIZE = `resize${EVENT_KEY4}`;
  var EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY4}`;
  var EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY4}`;
  var EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY4}`;
  var EVENT_CLICK_DATA_API3 = `click${EVENT_KEY4}${DATA_API_KEY3}`;
  var CLASS_NAME_OPEN = "modal-open";
  var CLASS_NAME_FADE2 = "fade";
  var CLASS_NAME_SHOW4 = "show";
  var CLASS_NAME_STATIC = "modal-static";
  var OPEN_SELECTOR = ".modal.show";
  var SELECTOR_DIALOG = ".modal-dialog";
  var SELECTOR_MODAL_BODY = ".modal-body";
  var SELECTOR_DATA_TOGGLE3 = '[data-bs-toggle="modal"]';
  var Default5 = {
    backdrop: true,
    focus: true,
    keyboard: true
  };
  var DefaultType5 = {
    backdrop: "(boolean|string)",
    focus: "boolean",
    keyboard: "boolean"
  };
  var Modal = class _Modal extends base_component_default {
    constructor(element, config) {
      super(element, config);
      this._dialog = selector_engine_default.findOne(SELECTOR_DIALOG, this._element);
      this._backdrop = this._initializeBackDrop();
      this._focustrap = this._initializeFocusTrap();
      this._isShown = false;
      this._isTransitioning = false;
      this._scrollBar = new scrollbar_default();
      this._addEventListeners();
    }
    // Getters
    static get Default() {
      return Default5;
    }
    static get DefaultType() {
      return DefaultType5;
    }
    static get NAME() {
      return NAME5;
    }
    // Public
    toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }
    show(relatedTarget) {
      if (this._isShown || this._isTransitioning) {
        return;
      }
      const showEvent = event_handler_default.trigger(this._element, EVENT_SHOW3, {
        relatedTarget
      });
      if (showEvent.defaultPrevented) {
        return;
      }
      this._isShown = true;
      this._isTransitioning = true;
      this._scrollBar.hide();
      document.body.classList.add(CLASS_NAME_OPEN);
      this._adjustDialog();
      this._backdrop.show(() => this._showElement(relatedTarget));
    }
    hide() {
      if (!this._isShown || this._isTransitioning) {
        return;
      }
      const hideEvent = event_handler_default.trigger(this._element, EVENT_HIDE3);
      if (hideEvent.defaultPrevented) {
        return;
      }
      this._isShown = false;
      this._isTransitioning = true;
      this._focustrap.deactivate();
      this._element.classList.remove(CLASS_NAME_SHOW4);
      this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());
    }
    dispose() {
      event_handler_default.off(window, EVENT_KEY4);
      event_handler_default.off(this._dialog, EVENT_KEY4);
      this._backdrop.dispose();
      this._focustrap.deactivate();
      super.dispose();
    }
    handleUpdate() {
      this._adjustDialog();
    }
    // Private
    _initializeBackDrop() {
      return new backdrop_default({
        isVisible: Boolean(this._config.backdrop),
        // 'static' option will be translated to true, and booleans will keep their value,
        isAnimated: this._isAnimated()
      });
    }
    _initializeFocusTrap() {
      return new focustrap_default({
        trapElement: this._element
      });
    }
    _showElement(relatedTarget) {
      if (!document.body.contains(this._element)) {
        document.body.append(this._element);
      }
      this._element.style.display = "block";
      this._element.removeAttribute("aria-hidden");
      this._element.setAttribute("aria-modal", true);
      this._element.setAttribute("role", "dialog");
      this._element.scrollTop = 0;
      const modalBody = selector_engine_default.findOne(SELECTOR_MODAL_BODY, this._dialog);
      if (modalBody) {
        modalBody.scrollTop = 0;
      }
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_SHOW4);
      const transitionComplete = () => {
        if (this._config.focus) {
          this._focustrap.activate();
        }
        this._isTransitioning = false;
        event_handler_default.trigger(this._element, EVENT_SHOWN3, {
          relatedTarget
        });
      };
      this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
    }
    _addEventListeners() {
      event_handler_default.on(this._element, EVENT_KEYDOWN_DISMISS, (event) => {
        if (event.key !== ESCAPE_KEY2) {
          return;
        }
        if (this._config.keyboard) {
          this.hide();
          return;
        }
        this._triggerBackdropTransition();
      });
      event_handler_default.on(window, EVENT_RESIZE, () => {
        if (this._isShown && !this._isTransitioning) {
          this._adjustDialog();
        }
      });
      event_handler_default.on(this._element, EVENT_MOUSEDOWN_DISMISS, (event) => {
        event_handler_default.one(this._element, EVENT_CLICK_DISMISS, (event2) => {
          if (this._element !== event.target || this._element !== event2.target) {
            return;
          }
          if (this._config.backdrop === "static") {
            this._triggerBackdropTransition();
            return;
          }
          if (this._config.backdrop) {
            this.hide();
          }
        });
      });
    }
    _hideModal() {
      this._element.style.display = "none";
      this._element.setAttribute("aria-hidden", true);
      this._element.removeAttribute("aria-modal");
      this._element.removeAttribute("role");
      this._isTransitioning = false;
      this._backdrop.hide(() => {
        document.body.classList.remove(CLASS_NAME_OPEN);
        this._resetAdjustments();
        this._scrollBar.reset();
        event_handler_default.trigger(this._element, EVENT_HIDDEN3);
      });
    }
    _isAnimated() {
      return this._element.classList.contains(CLASS_NAME_FADE2);
    }
    _triggerBackdropTransition() {
      const hideEvent = event_handler_default.trigger(this._element, EVENT_HIDE_PREVENTED);
      if (hideEvent.defaultPrevented) {
        return;
      }
      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
      const initialOverflowY = this._element.style.overflowY;
      if (initialOverflowY === "hidden" || this._element.classList.contains(CLASS_NAME_STATIC)) {
        return;
      }
      if (!isModalOverflowing) {
        this._element.style.overflowY = "hidden";
      }
      this._element.classList.add(CLASS_NAME_STATIC);
      this._queueCallback(() => {
        this._element.classList.remove(CLASS_NAME_STATIC);
        this._queueCallback(() => {
          this._element.style.overflowY = initialOverflowY;
        }, this._dialog);
      }, this._dialog);
      this._element.focus();
    }
    /**
     * The following methods are used to handle overflowing modals
     */
    _adjustDialog() {
      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
      const scrollbarWidth = this._scrollBar.getWidth();
      const isBodyOverflowing = scrollbarWidth > 0;
      if (isBodyOverflowing && !isModalOverflowing) {
        const property = isRTL() ? "paddingLeft" : "paddingRight";
        this._element.style[property] = `${scrollbarWidth}px`;
      }
      if (!isBodyOverflowing && isModalOverflowing) {
        const property = isRTL() ? "paddingRight" : "paddingLeft";
        this._element.style[property] = `${scrollbarWidth}px`;
      }
    }
    _resetAdjustments() {
      this._element.style.paddingLeft = "";
      this._element.style.paddingRight = "";
    }
    // Static
    static jQueryInterface(config, relatedTarget) {
      return this.each(function() {
        const data = _Modal.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](relatedTarget);
      });
    }
  };
  event_handler_default.on(document, EVENT_CLICK_DATA_API3, SELECTOR_DATA_TOGGLE3, function(event) {
    const target = selector_engine_default.getElementFromSelector(this);
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    event_handler_default.one(target, EVENT_SHOW3, (showEvent) => {
      if (showEvent.defaultPrevented) {
        return;
      }
      event_handler_default.one(target, EVENT_HIDDEN3, () => {
        if (isVisible(this)) {
          this.focus();
        }
      });
    });
    const alreadyOpen = selector_engine_default.findOne(OPEN_SELECTOR);
    if (alreadyOpen) {
      Modal.getInstance(alreadyOpen).hide();
    }
    const data = Modal.getOrCreateInstance(target);
    data.toggle(this);
  });
  enableDismissTrigger(Modal);
  defineJQueryPlugin(Modal);

  // ns-hugo:/tmp/hugo_cache/modules/filecache/modules/pkg/mod/github.com/twbs/bootstrap@v5.3.2+incompatible/js/src/tab.js
  var NAME6 = "tab";
  var DATA_KEY5 = "bs.tab";
  var EVENT_KEY5 = `.${DATA_KEY5}`;
  var EVENT_HIDE4 = `hide${EVENT_KEY5}`;
  var EVENT_HIDDEN4 = `hidden${EVENT_KEY5}`;
  var EVENT_SHOW4 = `show${EVENT_KEY5}`;
  var EVENT_SHOWN4 = `shown${EVENT_KEY5}`;
  var EVENT_CLICK_DATA_API4 = `click${EVENT_KEY5}`;
  var EVENT_KEYDOWN = `keydown${EVENT_KEY5}`;
  var EVENT_LOAD_DATA_API = `load${EVENT_KEY5}`;
  var ARROW_LEFT_KEY = "ArrowLeft";
  var ARROW_RIGHT_KEY = "ArrowRight";
  var ARROW_UP_KEY2 = "ArrowUp";
  var ARROW_DOWN_KEY2 = "ArrowDown";
  var HOME_KEY = "Home";
  var END_KEY = "End";
  var CLASS_NAME_ACTIVE = "active";
  var CLASS_NAME_FADE3 = "fade";
  var CLASS_NAME_SHOW5 = "show";
  var CLASS_DROPDOWN = "dropdown";
  var SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
  var SELECTOR_DROPDOWN_MENU = ".dropdown-menu";
  var NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;
  var SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
  var SELECTOR_OUTER = ".nav-item, .list-group-item";
  var SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;
  var SELECTOR_DATA_TOGGLE4 = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]';
  var SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE4}`;
  var SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`;
  var Tab = class _Tab extends base_component_default {
    constructor(element) {
      super(element);
      this._parent = this._element.closest(SELECTOR_TAB_PANEL);
      if (!this._parent) {
        return;
      }
      this._setInitialAttributes(this._parent, this._getChildren());
      event_handler_default.on(this._element, EVENT_KEYDOWN, (event) => this._keydown(event));
    }
    // Getters
    static get NAME() {
      return NAME6;
    }
    // Public
    show() {
      const innerElem = this._element;
      if (this._elemIsActive(innerElem)) {
        return;
      }
      const active = this._getActiveElem();
      const hideEvent = active ? event_handler_default.trigger(active, EVENT_HIDE4, { relatedTarget: innerElem }) : null;
      const showEvent = event_handler_default.trigger(innerElem, EVENT_SHOW4, { relatedTarget: active });
      if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {
        return;
      }
      this._deactivate(active, innerElem);
      this._activate(innerElem, active);
    }
    // Private
    _activate(element, relatedElem) {
      if (!element) {
        return;
      }
      element.classList.add(CLASS_NAME_ACTIVE);
      this._activate(selector_engine_default.getElementFromSelector(element));
      const complete = () => {
        if (element.getAttribute("role") !== "tab") {
          element.classList.add(CLASS_NAME_SHOW5);
          return;
        }
        element.removeAttribute("tabindex");
        element.setAttribute("aria-selected", true);
        this._toggleDropDown(element, true);
        event_handler_default.trigger(element, EVENT_SHOWN4, {
          relatedTarget: relatedElem
        });
      };
      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE3));
    }
    _deactivate(element, relatedElem) {
      if (!element) {
        return;
      }
      element.classList.remove(CLASS_NAME_ACTIVE);
      element.blur();
      this._deactivate(selector_engine_default.getElementFromSelector(element));
      const complete = () => {
        if (element.getAttribute("role") !== "tab") {
          element.classList.remove(CLASS_NAME_SHOW5);
          return;
        }
        element.setAttribute("aria-selected", false);
        element.setAttribute("tabindex", "-1");
        this._toggleDropDown(element, false);
        event_handler_default.trigger(element, EVENT_HIDDEN4, { relatedTarget: relatedElem });
      };
      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE3));
    }
    _keydown(event) {
      if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY2, ARROW_DOWN_KEY2, HOME_KEY, END_KEY].includes(event.key)) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      const children = this._getChildren().filter((element) => !isDisabled(element));
      let nextActiveElement;
      if ([HOME_KEY, END_KEY].includes(event.key)) {
        nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];
      } else {
        const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY2].includes(event.key);
        nextActiveElement = getNextActiveElement(children, event.target, isNext, true);
      }
      if (nextActiveElement) {
        nextActiveElement.focus({ preventScroll: true });
        _Tab.getOrCreateInstance(nextActiveElement).show();
      }
    }
    _getChildren() {
      return selector_engine_default.find(SELECTOR_INNER_ELEM, this._parent);
    }
    _getActiveElem() {
      return this._getChildren().find((child) => this._elemIsActive(child)) || null;
    }
    _setInitialAttributes(parent, children) {
      this._setAttributeIfNotExists(parent, "role", "tablist");
      for (const child of children) {
        this._setInitialAttributesOnChild(child);
      }
    }
    _setInitialAttributesOnChild(child) {
      child = this._getInnerElement(child);
      const isActive = this._elemIsActive(child);
      const outerElem = this._getOuterElement(child);
      child.setAttribute("aria-selected", isActive);
      if (outerElem !== child) {
        this._setAttributeIfNotExists(outerElem, "role", "presentation");
      }
      if (!isActive) {
        child.setAttribute("tabindex", "-1");
      }
      this._setAttributeIfNotExists(child, "role", "tab");
      this._setInitialAttributesOnTargetPanel(child);
    }
    _setInitialAttributesOnTargetPanel(child) {
      const target = selector_engine_default.getElementFromSelector(child);
      if (!target) {
        return;
      }
      this._setAttributeIfNotExists(target, "role", "tabpanel");
      if (child.id) {
        this._setAttributeIfNotExists(target, "aria-labelledby", `${child.id}`);
      }
    }
    _toggleDropDown(element, open) {
      const outerElem = this._getOuterElement(element);
      if (!outerElem.classList.contains(CLASS_DROPDOWN)) {
        return;
      }
      const toggle = (selector, className) => {
        const element2 = selector_engine_default.findOne(selector, outerElem);
        if (element2) {
          element2.classList.toggle(className, open);
        }
      };
      toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
      toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW5);
      outerElem.setAttribute("aria-expanded", open);
    }
    _setAttributeIfNotExists(element, attribute, value) {
      if (!element.hasAttribute(attribute)) {
        element.setAttribute(attribute, value);
      }
    }
    _elemIsActive(elem) {
      return elem.classList.contains(CLASS_NAME_ACTIVE);
    }
    // Try to get the inner element (usually the .nav-link)
    _getInnerElement(elem) {
      return elem.matches(SELECTOR_INNER_ELEM) ? elem : selector_engine_default.findOne(SELECTOR_INNER_ELEM, elem);
    }
    // Try to get the outer element (usually the .nav-item)
    _getOuterElement(elem) {
      return elem.closest(SELECTOR_OUTER) || elem;
    }
    // Static
    static jQueryInterface(config) {
      return this.each(function() {
        const data = _Tab.getOrCreateInstance(this);
        if (typeof config !== "string") {
          return;
        }
        if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
  };
  event_handler_default.on(document, EVENT_CLICK_DATA_API4, SELECTOR_DATA_TOGGLE4, function(event) {
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    Tab.getOrCreateInstance(this).show();
  });
  event_handler_default.on(window, EVENT_LOAD_DATA_API, () => {
    for (const element of selector_engine_default.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {
      Tab.getOrCreateInstance(element);
    }
  });
  defineJQueryPlugin(Tab);
})();
</script>































<script
  crossorigin="anonymous"
  integrity="sha256-SyT6nS49vJ1/Zx1siX9mn5ItqSp7UqeLYc/nzkEpijg="
  src="/js/scripts.min.4b24fa9d2e3dbc9d7f671d6c897f669f922da92a7b52a78b61cfe7ce41298a38.js"></script>





<script type="application/javascript">
  WebFont.load({
    google: {
      api: 'https://fonts.googleapis.com/css2',
      families: ['Fira\u002bSans:wght@400;500;700','Lato:wght@400;700&display=swap'],
      version: 2
    },
    active: () => {sessionStorage.fontsLoaded = true}
  });
</script>



<script>
  if ('serviceWorker' in navigator){navigator.serviceWorker.register("/service-worker.js");}
</script>





  






	
</body>

</html>